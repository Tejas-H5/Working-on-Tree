<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Currently working on</title>
      <script type="module" crossorigin>(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function assert(value) {
  if (value === false) {
    throw new Error("Assertion failed");
  }
}
function mustGetDefined(val, field = "this value") {
  if (val === void 0) throw new Error(`Expected ${field} to not be undefined`);
  return val;
}
const ENTRIES_IDX = 0;
const ENTRIES_LAST_IDX = 1;
const ENTRIES_REMOVE_LEVEL = 2;
const ENTRIES_IS_IN_CONDITIONAL_PATHWAY = 3;
const ENTRIES_IS_DERIVED = 4;
const ENTRIES_STARTED_CONDITIONALLY_RENDERING = 5;
const ENTRIES_DESTRUCTORS = 6;
const ENTRIES_KEYED_MAP = 7;
const ENTRIES_COMPLETED_ONE_RENDER = 8;
const ENTRIES_INTERNAL_TYPE = 9;
const ENTRIES_PARENT_TYPE = 10;
const ENTRIES_PARENT_VALUE = 11;
const ENTRIES_ITEMS_START = 12;
const CACHE_IDX = 0;
const CACHE_CURRENT_ENTRIES = 1;
const CACHE_CURRENT_WAITING_FOR_SET = 2;
const CACHE_CONTEXTS = 3;
const CACHE_ROOT_ENTRIES = 4;
const CACHE_NEEDS_RERENDER = 5;
const CACHE_RERENDER_FN = 6;
const CACHE_IS_RENDERING = 7;
const CACHE_ANIMATE_FN = 8;
const CACHE_ANIMATION_ID = 9;
const CACHE_ANIMATION_TIME = 10;
const CACHE_ANIMATION_DELTA_TIME_SECONDS = 11;
const CACHE_ITEMS_ITERATED = 12;
const CACHE_ENTRIES_START = 13;
const REMOVE_LEVEL_NONE = 1;
const REMOVE_LEVEL_DETATCHED = 2;
function inlineTypeId(fn) {
  return fn;
}
const USE_EVENT_LOOP = 1 << 0;
const USE_ANIMATION_FRAME = 1 << 1;
function imCacheBegin(c, renderFn, flags = USE_ANIMATION_FRAME) {
  if (c.length === 0) {
    c.length = CACHE_ENTRIES_START;
    c[CACHE_IDX] = 0;
    c[CACHE_CONTEXTS] = [];
    c[CACHE_ROOT_ENTRIES] = [];
    c[CACHE_CURRENT_ENTRIES] = c[CACHE_ROOT_ENTRIES];
    c[CACHE_CURRENT_WAITING_FOR_SET] = false;
    c[CACHE_NEEDS_RERENDER] = false;
    c[CACHE_ITEMS_ITERATED] = 0;
    c[CACHE_IS_RENDERING] = true;
    c[CACHE_RERENDER_FN] = () => {
      if (c[CACHE_IS_RENDERING] === true) {
        c[CACHE_NEEDS_RERENDER] = true;
      } else {
        renderFn(c);
      }
    };
    if (flags & USE_EVENT_LOOP) {
      c[CACHE_ANIMATION_TIME] = 0;
      c[CACHE_ANIMATION_DELTA_TIME_SECONDS] = 1 / 30;
      c[CACHE_ANIMATE_FN] = noOp;
      c[CACHE_ANIMATION_ID] = null;
    } else if (flags & USE_ANIMATION_FRAME) {
      c[CACHE_ANIMATION_TIME] = 0;
      c[CACHE_ANIMATION_DELTA_TIME_SECONDS] = 0;
      c[CACHE_ANIMATE_FN] = (t) => {
        if (c[CACHE_IS_RENDERING] === true) {
          return;
        }
        const lastT = c[CACHE_ANIMATION_TIME];
        c[CACHE_ANIMATION_TIME] = t;
        c[CACHE_ANIMATION_DELTA_TIME_SECONDS] = (t - lastT) / 1e3;
        renderFn(c);
      };
      c[CACHE_ANIMATION_ID] = 0;
    } else {
      throw new Error("Invalid flags");
    }
  }
  c[CACHE_IS_RENDERING] = true;
  c[CACHE_IDX] = CACHE_ENTRIES_START - 1;
  c[CACHE_NEEDS_RERENDER] = false;
  c[CACHE_ITEMS_ITERATED] = 0;
  c[CACHE_CURRENT_WAITING_FOR_SET] = false;
  imCacheEntriesBegin(c, c[CACHE_ROOT_ENTRIES], imCacheBegin, c, INTERNAL_TYPE_CACHE);
  return c;
}
function noOp() {
}
function imCacheEnd(c) {
  imCacheEntriesEnd(c);
  const startIdx = CACHE_ENTRIES_START - 1;
  if (c[CACHE_IDX] > startIdx) {
    console.error("You've forgotten to pop some things: ", c.slice(startIdx + 1));
    throw new Error("You've forgotten to pop some things");
  } else if (c[CACHE_IDX] < startIdx) {
    throw new Error("You've popped too many thigns off the stack!!!!");
  }
  c[CACHE_IS_RENDERING] = false;
  const needsRerender = c[CACHE_NEEDS_RERENDER];
  if (needsRerender === true) {
    c[CACHE_RERENDER_FN]();
    c[CACHE_NEEDS_RERENDER] = false;
  } else if (c[CACHE_ANIMATE_FN] !== noOp) {
    cancelAnimationFrame(c[CACHE_ANIMATION_ID]);
    c[CACHE_ANIMATION_ID] = requestAnimationFrame(c[CACHE_ANIMATE_FN]);
  }
}
const INTERNAL_TYPE_NORMAL_BLOCK = 1;
const INTERNAL_TYPE_CONDITIONAL_BLOCK = 2;
const INTERNAL_TYPE_ARRAY_BLOCK = 3;
const INTERNAL_TYPE_KEYED_BLOCK = 4;
const INTERNAL_TYPE_TRY_BLOCK = 5;
const INTERNAL_TYPE_CACHE = 6;
function imCacheEntriesBegin(c, entries, parentTypeId, parent, internalType) {
  const idx = ++c[CACHE_IDX];
  if (idx === c.length) {
    c.push(entries);
  } else {
    c[idx] = entries;
  }
  c[CACHE_CURRENT_ENTRIES] = entries;
  if (entries.length === 0) {
    entries.length = ENTRIES_ITEMS_START;
    entries[ENTRIES_IDX] = ENTRIES_ITEMS_START - 2;
    entries[ENTRIES_LAST_IDX] = ENTRIES_ITEMS_START - 2;
    entries[ENTRIES_REMOVE_LEVEL] = REMOVE_LEVEL_DETATCHED;
    entries[ENTRIES_IS_IN_CONDITIONAL_PATHWAY] = false;
    entries[ENTRIES_IS_DERIVED] = false;
    entries[ENTRIES_STARTED_CONDITIONALLY_RENDERING] = false;
    entries[ENTRIES_PARENT_TYPE] = parentTypeId;
    entries[ENTRIES_INTERNAL_TYPE] = internalType;
    entries[ENTRIES_COMPLETED_ONE_RENDER] = false;
    entries[ENTRIES_PARENT_VALUE] = parent;
    entries[ENTRIES_DESTRUCTORS] = void 0;
    entries[ENTRIES_KEYED_MAP] = void 0;
  } else {
    assert(entries[ENTRIES_PARENT_TYPE] === parentTypeId);
  }
  entries[ENTRIES_IDX] = ENTRIES_ITEMS_START - 2;
}
function imCacheEntriesEnd(c) {
  const idx = --c[CACHE_IDX];
  c[CACHE_CURRENT_ENTRIES] = c[idx];
  assert(idx >= CACHE_ENTRIES_START - 1);
}
function imGet(c, typeId, initialValue = void 0) {
  const entries = c[CACHE_CURRENT_ENTRIES];
  c[CACHE_ITEMS_ITERATED]++;
  assert(!c[CACHE_CURRENT_WAITING_FOR_SET]);
  entries[ENTRIES_IDX] += 2;
  const idx = entries[ENTRIES_IDX];
  if (idx === ENTRIES_ITEMS_START) {
    if (entries[ENTRIES_IS_IN_CONDITIONAL_PATHWAY] === false) {
      entries[ENTRIES_IS_IN_CONDITIONAL_PATHWAY] = true;
      entries[ENTRIES_STARTED_CONDITIONALLY_RENDERING] = true;
      entries[ENTRIES_REMOVE_LEVEL] = REMOVE_LEVEL_NONE;
    } else {
      entries[ENTRIES_STARTED_CONDITIONALLY_RENDERING] = false;
    }
  }
  if (idx === entries.length) {
    entries.push(typeId);
    entries.push(initialValue);
    c[CACHE_CURRENT_WAITING_FOR_SET] = true;
  } else if (idx < entries.length) {
    assert(entries[idx] === typeId);
  } else {
    throw new Error("Shouldn't reach here");
  }
  return entries[idx + 1];
}
function getEntriesParent(c, typeId) {
  const entries = c[CACHE_CURRENT_ENTRIES];
  assert(entries[ENTRIES_PARENT_TYPE] === typeId);
  return entries[ENTRIES_PARENT_VALUE];
}
function imSet(c, val) {
  const entries = c[CACHE_CURRENT_ENTRIES];
  const idx = entries[ENTRIES_IDX];
  entries[idx + 1] = val;
  c[CACHE_CURRENT_WAITING_FOR_SET] = false;
  return val;
}
function __imBlockKeyedBegin(c, key) {
  const entries = c[CACHE_CURRENT_ENTRIES];
  let map = entries[ENTRIES_KEYED_MAP];
  if (map === void 0) {
    map = /* @__PURE__ */ new Map();
    entries[ENTRIES_KEYED_MAP] = map;
  }
  let block = map.get(key);
  if (block === void 0) {
    block = { rendered: false, entries: [] };
    map.set(key, block);
  }
  if (block.rendered === true) throw new Error(
    "You've requested the same list key twice. This is indicative of a bug. The comment above this exception will explain more."
  );
  block.rendered = true;
  const parentType = entries[ENTRIES_PARENT_TYPE];
  const parent = entries[ENTRIES_PARENT_VALUE];
  imCacheEntriesBegin(c, block.entries, parentType, parent, INTERNAL_TYPE_KEYED_BLOCK);
}
function imKeyedBegin(c, key) {
  __imBlockKeyedBegin(c, key);
}
function imKeyedEnd(c) {
  __imBlockDerivedEnd(c, INTERNAL_TYPE_KEYED_BLOCK);
}
function imCacheEntriesAddDestructor(c, destructor) {
  const entries = c[CACHE_CURRENT_ENTRIES];
  let destructors = entries[ENTRIES_DESTRUCTORS];
  if (destructors === void 0) {
    destructors = [];
    entries[ENTRIES_DESTRUCTORS] = destructors;
  }
  destructors.push(destructor);
}
function imCacheEntriesOnRemove(entries) {
  if (entries[ENTRIES_IS_IN_CONDITIONAL_PATHWAY] === true) {
    entries[ENTRIES_IS_IN_CONDITIONAL_PATHWAY] = false;
    for (let i = ENTRIES_ITEMS_START; i < entries.length; i += 2) {
      const t = entries[i];
      const v = entries[i + 1];
      if (t === imBlockBegin) {
        imCacheEntriesOnRemove(v);
      }
    }
  }
}
function imBlockBegin(c, parentTypeId, parent, internalType = INTERNAL_TYPE_NORMAL_BLOCK) {
  let entries;
  entries = imGet(c, imBlockBegin);
  if (entries === void 0) entries = imSet(c, []);
  imCacheEntriesBegin(c, entries, parentTypeId, parent, internalType);
  const map = entries[ENTRIES_KEYED_MAP];
  if (map !== void 0) {
    for (const v of map.values()) {
      v.rendered = false;
    }
  }
  return entries;
}
function imBlockEnd(c, internalType = INTERNAL_TYPE_NORMAL_BLOCK) {
  const entries = c[CACHE_CURRENT_ENTRIES];
  let map = entries[ENTRIES_KEYED_MAP];
  assert(entries[ENTRIES_INTERNAL_TYPE] === internalType);
  if (map !== void 0) {
    for (const v of map.values()) {
      if (!v.rendered) {
        imCacheEntriesOnRemove(v.entries);
      }
    }
  }
  const idx = entries[ENTRIES_IDX];
  entries[ENTRIES_COMPLETED_ONE_RENDER] = true;
  const lastIdx = entries[ENTRIES_LAST_IDX];
  if (idx !== ENTRIES_ITEMS_START - 2) {
    if (lastIdx === ENTRIES_ITEMS_START - 2) {
      entries[ENTRIES_LAST_IDX] = idx;
    } else if (idx !== lastIdx) {
      throw new Error("You should be rendering the same number of things in every render cycle");
    }
  }
  return imCacheEntriesEnd(c);
}
function __imBlockDerivedBegin(c, internalType) {
  const entries = c[CACHE_CURRENT_ENTRIES];
  const parentType = entries[ENTRIES_PARENT_TYPE];
  const parent = entries[ENTRIES_PARENT_VALUE];
  return imBlockBegin(c, parentType, parent, internalType);
}
function isFirstishRender(c) {
  const entries = c[CACHE_CURRENT_ENTRIES];
  return entries[ENTRIES_COMPLETED_ONE_RENDER] === false;
}
function __imBlockDerivedEnd(c, internalType) {
  imBlockEnd(c, internalType);
}
function imIf(c) {
  __imBlockArrayBegin(c);
  __imBlockConditionalBegin(c);
  return true;
}
function imIfElse(c) {
  __imBlockConditionalEnd(c);
  __imBlockConditionalBegin(c);
  return true;
}
function imIfEnd(c) {
  __imBlockConditionalEnd(c);
  __imBlockArrayEnd(c);
}
function imSwitch(c, key) {
  __imBlockKeyedBegin(c, key);
}
function imSwitchEnd(c) {
  __imBlockDerivedEnd(c, INTERNAL_TYPE_KEYED_BLOCK);
}
function __imBlockArrayBegin(c) {
  __imBlockDerivedBegin(c, INTERNAL_TYPE_ARRAY_BLOCK);
}
function __imBlockConditionalBegin(c) {
  __imBlockDerivedBegin(c, INTERNAL_TYPE_CONDITIONAL_BLOCK);
}
function __imBlockConditionalEnd(c) {
  const entries = c[CACHE_CURRENT_ENTRIES];
  if (entries[ENTRIES_IDX] === ENTRIES_ITEMS_START - 2) {
    imCacheEntriesOnRemove(entries);
  }
  __imBlockDerivedEnd(c, INTERNAL_TYPE_CONDITIONAL_BLOCK);
}
function imFor(c) {
  __imBlockArrayBegin(c);
}
function imForEnd(c) {
  __imBlockArrayEnd(c);
}
function __imBlockArrayEnd(c) {
  const entries = c[CACHE_CURRENT_ENTRIES];
  const idx = entries[ENTRIES_IDX];
  const lastIdx = entries[ENTRIES_LAST_IDX];
  if (idx < lastIdx) {
    for (let i = idx + 2; i <= lastIdx; i += 2) {
      const t = entries[i];
      const v = entries[i + 1];
      if (t === imBlockBegin) {
        imCacheEntriesOnRemove(v);
      }
    }
  }
  entries[ENTRIES_LAST_IDX] = idx;
  __imBlockDerivedEnd(c, INTERNAL_TYPE_ARRAY_BLOCK);
}
const IM_MEMO_FIRST_EVER = {};
const MEMO_NOT_CHANGED = 0;
const MEMO_CHANGED = 1;
const MEMO_FIRST_RENDER_CONDITIONAL = 3;
const MEMO_FIRST_RENDER_EVER = 4;
function imMemo(c, val) {
  let result = MEMO_NOT_CHANGED;
  const entries = c[CACHE_CURRENT_ENTRIES];
  let lastVal = imGet(c, inlineTypeId(imMemo), IM_MEMO_FIRST_EVER);
  if (lastVal !== val) {
    imSet(c, val);
    if (lastVal === IM_MEMO_FIRST_EVER) {
      result = MEMO_FIRST_RENDER_EVER;
    } else {
      result = MEMO_CHANGED;
    }
  } else if (entries[ENTRIES_STARTED_CONDITIONALLY_RENDERING] === true) {
    result = MEMO_FIRST_RENDER_CONDITIONAL;
  }
  return result;
}
function imTry(c) {
  const entries = __imBlockDerivedBegin(c, INTERNAL_TYPE_TRY_BLOCK);
  let tryState = imGet(c, imTry);
  if (tryState === void 0) {
    const val = {
      err: null,
      recover: () => {
        val.err = null;
        c[CACHE_NEEDS_RERENDER] = true;
      },
      entries
    };
    tryState = imSet(c, val);
  }
  return tryState;
}
function imTryCatch(c, tryState, err) {
  if (tryState.err != null) {
    throw new Error("Your error boundary pathway also has an error in it, so we can't recover!");
  }
  c[CACHE_NEEDS_RERENDER] = true;
  tryState.err = err;
  const idx = c.lastIndexOf(tryState.entries);
  if (idx === -1) {
    throw new Error("Couldn't find the entries in the stack to unwind to!");
  }
  c[CACHE_IDX] = idx;
  c[CACHE_CURRENT_ENTRIES] = c[idx];
}
function imTryEnd(c, tryState) {
  const entries = c[CACHE_CURRENT_ENTRIES];
  assert(entries === tryState.entries);
  __imBlockDerivedEnd(c, INTERNAL_TYPE_TRY_BLOCK);
}
function getDeltaTimeSeconds(c) {
  return c[CACHE_ANIMATION_DELTA_TIME_SECONDS];
}
function newDomAppender(root, children) {
  return {
    root,
    ref: null,
    idx: -1,
    children,
    lastIdx: -1,
    manualDom: false,
    rendered: false,
    parentIdx: -1,
    childrenChanged: false
  };
}
function appendToDomRoot(appender, child) {
  assert(appender.children !== null);
  const idx = ++appender.idx;
  if (idx === appender.children.length) {
    appender.children.push(child);
    child.parentIdx = idx;
    appender.childrenChanged = true;
  } else if (idx < appender.children.length) {
    if (appender.children[idx] !== child) {
      if (child.parentIdx === -1) {
        const a = appender.children[idx];
        a.parentIdx = appender.children.length;
        appender.children.push(a);
        appender.children[idx] = child;
        child.parentIdx = idx;
      } else {
        assert(appender.children[child.parentIdx] === child);
        appender.children[child.parentIdx] = appender.children[idx];
        appender.children[child.parentIdx].parentIdx = child.parentIdx;
        appender.children[idx] = child;
        appender.children[idx].parentIdx = idx;
      }
      assert(appender.children[idx].parentIdx === idx);
      assert(appender.children[child.parentIdx] === child);
      appender.childrenChanged = true;
    }
  } else {
    throw new Error("Unreachable");
  }
}
function finalizeDomAppender(appender) {
  if (appender.children !== null && (appender.childrenChanged || appender.lastIdx !== appender.idx)) {
    appender.childrenChanged = false;
    for (let i = 0; i <= appender.idx; i++) {
      const val = appender.children[i];
      const realChildren = appender.root.children;
      if (i >= realChildren.length) {
        appender.root.append(val.root);
      } else if (realChildren[i] !== val.root) {
        appender.root.insertBefore(val.root, realChildren[i]);
      }
    }
    for (let i = appender.idx + 1; i < appender.children.length; i++) {
      appender.children[i].root.remove();
    }
    appender.lastIdx = appender.idx;
  }
}
function imElBegin(c, r) {
  const appender = getEntriesParent(c, newDomAppender);
  let childAppender = imGet(c, newDomAppender);
  if (childAppender === void 0) {
    const element = document.createElement(r.val);
    childAppender = imSet(c, newDomAppender(element, []));
    childAppender.ref = r;
  }
  appendToDomRoot(appender, childAppender);
  imBlockBegin(c, newDomAppender, childAppender);
  childAppender.idx = -1;
  return childAppender;
}
function imElEnd(c, r) {
  const appender = getEntriesParent(c, newDomAppender);
  assert(appender.ref === r);
  finalizeDomAppender(appender);
  imBlockEnd(c);
}
function imDomRootBegin(c, root) {
  let appender = imGet(c, newDomAppender);
  if (appender === void 0) {
    appender = imSet(c, newDomAppender(root, []));
    appender.ref = root;
  }
  imBlockBegin(c, newDomAppender, appender);
  appender.idx = -1;
  return appender;
}
function imDomRootEnd(c, root) {
  let appender = getEntriesParent(c, newDomAppender);
  assert(appender.ref === root);
  finalizeDomAppender(appender);
  imBlockEnd(c);
}
function imStr(c, value) {
  let textNodeLeafAppender;
  textNodeLeafAppender = imGet(c, inlineTypeId(imStr));
  if (textNodeLeafAppender === void 0) textNodeLeafAppender = imSet(c, newDomAppender(document.createTextNode(""), null));
  let lastValue = imGet(c, inlineTypeId(document.createTextNode));
  if (lastValue !== value) {
    imSet(c, value);
    textNodeLeafAppender.root.nodeValue = value.toString();
  }
  const domAppender = getEntriesParent(c, newDomAppender);
  appendToDomRoot(domAppender, textNodeLeafAppender);
  return textNodeLeafAppender.root;
}
function elSetStyle(c, key, value, root = elGet(c)) {
  root.style[key] = value;
}
function elSetTextSafetyRemoved(c, val) {
  let el = elGet(c);
  el.textContent = val;
}
function elSetClass(c, className, enabled = true) {
  const domAppender = getEntriesParent(c, newDomAppender);
  if (enabled !== false && enabled !== 0) {
    domAppender.root.classList.add(className);
  } else {
    domAppender.root.classList.remove(className);
  }
  return !!enabled;
}
function elSetAttr(c, attr, val) {
  const domAppender = getEntriesParent(c, newDomAppender);
  if (val !== null) {
    domAppender.root.setAttribute(attr, val);
  } else {
    domAppender.root.removeAttribute(attr);
  }
}
function elGetAppender(c) {
  return getEntriesParent(c, newDomAppender);
}
function elGet(c) {
  return elGetAppender(c).root;
}
function imOn(c, type) {
  let state2;
  state2 = imGet(c, inlineTypeId(imOn));
  if (!state2) {
    const val = {
      el: elGet(c),
      eventType: null,
      eventValue: null,
      eventListener: (e) => {
        val.eventValue = e;
        c[CACHE_RERENDER_FN]();
      }
    };
    state2 = imSet(c, val);
  }
  let result = null;
  if (state2.eventValue !== null) {
    result = state2.eventValue;
    state2.eventValue = null;
  }
  if (state2.eventType !== type) {
    const el = elGet(c);
    if (state2.eventType !== null) {
      el.removeEventListener(state2.eventType.val, state2.eventListener);
    }
    state2.eventType = type;
    el.addEventListener(state2.eventType.val, state2.eventListener);
  }
  return result;
}
function elHasMouseDown(c, ev) {
  const el = elGet(c);
  return elIsInSetThisFrame(el, ev.mouse.mouseDownElements);
}
function elHasMouseOver(c, ev) {
  const el = elGet(c);
  return ev.mouse.mouseOverElements.has(el);
}
function elIsInSetThisFrame(el, set) {
  const result = set.has(el);
  set.delete(el);
  return result;
}
function findParents(el, elements) {
  elements.clear();
  let current = el;
  while (current !== null) {
    elements.add(current);
    current = current.parentElement;
  }
}
function newImGlobalEventSystem() {
  const keyboard = {
    keyDown: null,
    keyUp: null,
    blur: false
  };
  const mouse = {
    lastX: 0,
    lastY: 0,
    leftMouseButton: false,
    middleMouseButton: false,
    rightMouseButton: false,
    dX: 0,
    dY: 0,
    X: 0,
    Y: 0,
    scrollWheel: 0,
    mouseDownElements: /* @__PURE__ */ new Set(),
    mouseUpElements: /* @__PURE__ */ new Set(),
    mouseClickElements: /* @__PURE__ */ new Set(),
    mouseOverElements: /* @__PURE__ */ new Set(),
    lastMouseOverElement: null
  };
  const handleMouseMove = (e) => {
    mouse.lastX = mouse.X;
    mouse.lastY = mouse.Y;
    mouse.X = e.clientX;
    mouse.Y = e.clientY;
    mouse.dX += mouse.X - mouse.lastX;
    mouse.dY += mouse.Y - mouse.lastY;
    if (mouse.lastMouseOverElement !== e.target) {
      mouse.lastMouseOverElement = e.target;
      findParents(e.target, mouse.mouseOverElements);
      return true;
    }
    return false;
  };
  const eventSystem = {
    // You should set this to your rerender method
    rerender: () => {
    },
    keyboard,
    mouse,
    // stored, so we can dispose them later if needed.
    globalEventHandlers: {
      mousedown: (e) => {
        if (e.button === 0) {
          mouse.leftMouseButton = true;
        } else if (e.button === 1) {
          mouse.middleMouseButton = true;
        } else if (e.button === 2) {
          mouse.rightMouseButton = true;
        }
        findParents(e.target, mouse.mouseDownElements);
        try {
          eventSystem.rerender();
        } finally {
          mouse.mouseDownElements.clear();
        }
      },
      mouseClick: (e) => {
        findParents(e.target, mouse.mouseClickElements);
        try {
          eventSystem.rerender();
        } finally {
          mouse.mouseClickElements.clear();
        }
      },
      mousemove: (e) => {
        if (handleMouseMove(e)) eventSystem.rerender();
      },
      mouseenter: (e) => {
        if (handleMouseMove(e)) eventSystem.rerender();
      },
      mouseup: (e) => {
        if (e.button === 0) {
          mouse.leftMouseButton = false;
        } else if (e.button === 1) {
          mouse.middleMouseButton = false;
        } else if (e.button === 2) {
          mouse.rightMouseButton = false;
        }
        findParents(e.target, mouse.mouseUpElements);
        try {
          eventSystem.rerender();
        } finally {
          mouse.mouseUpElements.clear();
        }
        eventSystem.rerender();
      },
      wheel: (e) => {
        mouse.scrollWheel += e.deltaX + e.deltaY + e.deltaZ;
        e.preventDefault();
        if (!handleMouseMove(e)) {
          eventSystem.rerender();
        }
      },
      keydown: (e) => {
        keyboard.keyDown = e;
        eventSystem.rerender();
      },
      keyup: (e) => {
        keyboard.keyUp = e;
        eventSystem.rerender();
      },
      blur: () => {
        resetMouseState(mouse, true);
        resetKeyboardState$1(keyboard);
        keyboard.blur = true;
        eventSystem.rerender();
      }
    }
  };
  return eventSystem;
}
function resetKeyboardState$1(keyboard) {
  keyboard.keyDown = null;
  keyboard.keyUp = null;
  keyboard.blur = false;
}
function imGlobalEventSystemBegin(c, eventSystem) {
  let state2 = imGet(c, newImGlobalEventSystem);
  if (state2 !== eventSystem) {
    if (state2 !== void 0) {
      throw new Error("This code can't handle changing the event system like that yet - we need to remove the last destructor somehow before we can do this.");
    }
    eventSystem.rerender = c[CACHE_RERENDER_FN];
    addDocumentAndWindowEventListeners(eventSystem);
    imCacheEntriesAddDestructor(c, () => removeDocumentAndWindowEventListeners(eventSystem));
    state2 = imSet(c, eventSystem);
  }
  return state2;
}
function imGlobalEventSystemEnd(c, eventSystem) {
  endProcessingImEvent(eventSystem);
}
function endProcessingImEvent(eventSystem) {
  resetKeyboardState$1(eventSystem.keyboard);
  resetMouseState(eventSystem.mouse, false);
}
function resetMouseState(mouse, clearPersistedStateAsWell) {
  mouse.dX = 0;
  mouse.dY = 0;
  mouse.lastX = mouse.X;
  mouse.lastY = mouse.Y;
  mouse.scrollWheel = 0;
  if (clearPersistedStateAsWell === true) {
    mouse.leftMouseButton = false;
    mouse.middleMouseButton = false;
    mouse.rightMouseButton = false;
  }
}
function addDocumentAndWindowEventListeners(eventSystem) {
  document.addEventListener("mousedown", eventSystem.globalEventHandlers.mousedown);
  document.addEventListener("mousemove", eventSystem.globalEventHandlers.mousemove);
  document.addEventListener("mouseenter", eventSystem.globalEventHandlers.mouseenter);
  document.addEventListener("mouseup", eventSystem.globalEventHandlers.mouseup);
  document.addEventListener("wheel", eventSystem.globalEventHandlers.wheel);
  document.addEventListener("keydown", eventSystem.globalEventHandlers.keydown);
  document.addEventListener("keyup", eventSystem.globalEventHandlers.keyup);
  window.addEventListener("blur", eventSystem.globalEventHandlers.blur);
}
function removeDocumentAndWindowEventListeners(eventSystem) {
  document.removeEventListener("mousedown", eventSystem.globalEventHandlers.mousedown);
  document.removeEventListener("mousemove", eventSystem.globalEventHandlers.mousemove);
  document.removeEventListener("mouseenter", eventSystem.globalEventHandlers.mouseenter);
  document.removeEventListener("mouseup", eventSystem.globalEventHandlers.mouseup);
  document.removeEventListener("wheel", eventSystem.globalEventHandlers.wheel);
  document.removeEventListener("keydown", eventSystem.globalEventHandlers.keydown);
  document.removeEventListener("keyup", eventSystem.globalEventHandlers.keyup);
  window.removeEventListener("blur", eventSystem.globalEventHandlers.blur);
}
const EL_A = { val: "a" };
const EL_B = { val: "b" };
const EL_DIV = { val: "div" };
const EL_H1 = { val: "h1" };
const EL_I = { val: "i" };
const EL_TEXTAREA = { val: "textarea" };
const EV_CHANGE = { val: "change" };
const EV_FOCUS = { val: "focus" };
const EV_INPUT = { val: "input" };
const EV_KEYDOWN = { val: "keydown" };
function newColor(r, g, b, a) {
  return {
    r,
    g,
    b,
    a,
    toCssString(aOverride) {
      const { r: r2, g: g2, b: b2, a: a2 } = this;
      return `rgba(${Math.floor(r2 * 255)}, ${Math.floor(g2 * 255)}, ${Math.floor(b2 * 255)}, ${aOverride ?? a2})`;
    },
    toString() {
      return this.toCssString();
    }
  };
}
function newColorFromHexOrUndefined(hex) {
  if (hex.startsWith("#")) {
    hex = hex.substring(1);
  }
  if (hex.length === 3 || hex.length === 4) {
    const r = hex[0];
    const g = hex[1];
    const b = hex[2];
    const a = hex[3];
    return newColor(
      parseInt("0x" + r + r) / 255,
      parseInt("0x" + g + g) / 255,
      parseInt("0x" + b + b) / 255,
      a ? parseInt("0x" + a + a) / 255 : 1
    );
  }
  if (hex.length === 6 || hex.length === 8) {
    const r = hex.substring(0, 2);
    const g = hex.substring(2, 4);
    const b = hex.substring(4, 6);
    const a = hex.substring(6);
    return newColor(
      parseInt("0x" + r) / 255,
      parseInt("0x" + g) / 255,
      parseInt("0x" + b) / 255,
      a ? parseInt("0x" + a) / 255 : 1
    );
  }
  return void 0;
}
function newColorFromHex(hex) {
  const col = newColorFromHexOrUndefined(hex);
  if (!col) {
    throw new Error("invalid hex: " + hex);
  }
  return col;
}
function newStyleElement() {
  return document.createElement("style");
}
const stylesStringBuilder = [];
const allClassNames = /* @__PURE__ */ new Set();
function initCssbStyles(stylesRoot) {
  if (!stylesRoot) {
    stylesRoot = document.head;
  }
  const sb = stylesStringBuilder;
  if (sb.length > 0) {
    const text = sb.join("");
    stylesStringBuilder.length = 0;
    const styleNode = newStyleElement();
    styleNode.setAttribute("type", "text/css");
    styleNode.textContent = "\n\n" + text + "\n\n";
    stylesRoot.append(styleNode);
  }
}
function newCssBuilder(prefix = "") {
  const builder = stylesStringBuilder;
  return {
    /** Appends a CSS style to the builder. The prefix is not used. */
    s(string) {
      builder.push(string);
    },
    /** Returns `prefix + className`. Throws if it somehow clashes with an existing class someone else made. */
    newClassName(className) {
      let name = prefix + className;
      if (allClassNames.has(name)) {
        throw new Error("We've already made a class with this name: " + name + " - consider adding a prefix");
      }
      allClassNames.add(name);
      return name;
    },
    // makes a new class, it's variants, and returns the class name
    cn(className, styles) {
      const name = this.newClassName(className);
      for (let style of styles) {
        const finalStyle = `.${name}${style}`;
        builder.push(finalStyle + "\n");
      }
      return name;
    }
  };
}
function setCssVars(vars, cssRoot) {
  if (!cssRoot) {
    cssRoot = document.querySelector(":root");
  }
  for (const k in vars) {
    setCssVar(cssRoot, k, vars[k]);
  }
}
function setCssVar(cssRoot, varName, value) {
  const fullVarName = `--${varName}`;
  cssRoot.style.setProperty(fullVarName, "" + value);
}
const defaultCoreTheme = Object.freeze({
  bg: newColorFromHex("#FFF"),
  bg2: newColorFromHex("#CCC"),
  mg: newColorFromHex("#888"),
  fg2: newColorFromHex("#333"),
  fg: newColorFromHex("#000"),
  mediumText: "4rem",
  normalText: "1.5rem",
  smallText: "1rem"
});
const cssVars = Object.freeze({
  bg: "var(--bg)",
  bg2: "var(--bg2)",
  mg: "var(--mg)",
  fg2: "var(--fg2)",
  fg: "var(--fg)",
  mediumText: "var(--mediumText)",
  normalText: "var(--normalText)",
  smallText: "var(--smallText)"
});
setCssVars(defaultCoreTheme);
const cssb$4 = newCssBuilder();
const cnHoverParent = cssb$4.newClassName("hoverParent");
const cnHoverTarget = cssb$4.newClassName("hoverTarget");
const cnHoverTargetInverse = cssb$4.newClassName("hoverTargetInverse");
cssb$4.s(`
.${cnHoverParent} .${cnHoverTarget} { display: none !important; }
.${cnHoverParent} .${cnHoverTargetInverse} { display: inherit !important; }
.${cnHoverParent}:hover .${cnHoverTarget}  { display: inherit !important; }
.${cnHoverParent}:hover .${cnHoverTargetInverse}  { display: none !important; }
`);
const cn = Object.freeze({
  allUnset: cssb$4.cn("allUnset", [` { all: unset; }`]),
  row: cssb$4.cn("row", [` { display: flex; flex-direction: row; }`]),
  rowReverse: cssb$4.cn("row-reverse", [` { display: flex; flex-direction: row-reverse; }`]),
  col: cssb$4.cn("col", [` { display: flex; flex-direction: column; }`]),
  colReverse: cssb$4.cn("col-reverse", [` { display: flex; flex-direction: column-reverse; }`]),
  flexWrap: cssb$4.cn("flexWrap", [` { display: flex; flex-flow: wrap; }`]),
  /** The min-width and min-height here is the secret sauce. Now the flex containers won't keep overflowing lmao */
  flex1: cssb$4.cn("flex1", [` { flex: 1; min-width: 0; min-height: 0; }`]),
  alignItemsCenter: cssb$4.cn("alignItemsCenter", [` { align-items: center; }`]),
  justifyContentLeft: cssb$4.cn("justifyContentLeft", [` { justify-content: left; }`]),
  justifyContentRight: cssb$4.cn("justifyContentRight", [` { justify-content: right; }`]),
  justifyContentCenter: cssb$4.cn("justifyContentCenter", [` { justify-content: center; }`]),
  justifyContentStart: cssb$4.cn("justifyContentStart", [` { justify-content: start; }`]),
  justifyContentEnd: cssb$4.cn("justifyContentEnd", [` { justify-content: end; }`]),
  alignItemsEnd: cssb$4.cn("alignItemsEnd", [` { align-items: flex-end; }`]),
  alignItemsStart: cssb$4.cn("alignItemsStart", [` { align-items: flex-start; }`]),
  alignItemsStretch: cssb$4.cn("alignItemsStretch", [` { align-items: stretch; }`]),
  /** positioning */
  fixed: cssb$4.cn("fixed", [` { position: fixed; }`]),
  sticky: cssb$4.cn("sticky", [` { position: sticky; }`]),
  absolute: cssb$4.cn("absolute", [` { position: absolute; }`]),
  relative: cssb$4.cn("relative", [` { position: relative; }`]),
  absoluteFill: cssb$4.cn("absoluteFill", [` { position: absolute; top: 0; right: 0; left: 0; bottom: 0; width: 100%; height: 100%; }`]),
  borderBox: cssb$4.cn("borderBox", [` { box-sizing: border-box; }`]),
  /** displays */
  inlineBlock: cssb$4.cn("inlineBlock", [` { display: inline-block; }`]),
  inline: cssb$4.cn("inline", [` { display: inline; }`]),
  flex: cssb$4.cn("flex", [` { display: flex; }`]),
  pointerEventsNone: cssb$4.cn("pointerEventsNone", [` { pointer-events: none; }`]),
  pointerEventsAll: cssb$4.cn("pointerEventsAll", [` { pointer-events: all; }`]),
  userSelectNone: cssb$4.cn("userSelectNone", [` { user-select: none; }`]),
  table: cssb$4.cn("table", [` { display: table; }`]),
  tableRow: cssb$4.cn("tableRow", [` { display: table-row; }`]),
  tableCell: cssb$4.cn("tableCell", [` { display: table-cell; }`]),
  /** we have React.Fragment at home. Kinda useless now, since our components can just render multiple things under another thing. */
  contents: cssb$4.cn("contents", [` { display: contents; }`]),
  /** common spacings */
  w100: cssb$4.cn("w100", [` { width: 100%; }`]),
  mw100: cssb$4.cn("mw100", [` { max-width: 100%; }`]),
  h100: cssb$4.cn("h100", [` { height: 100%; }`]),
  mh100: cssb$4.cn("mh100", [` { max-height: 100%; }`]),
  wFitContent: cssb$4.cn("wFitContent", [` { width: fit-content; }`]),
  hFitContent: cssb$4.cn("hFitContent", [` { height: fit-content; }`]),
  /** overflow management */
  overflowXAuto: cssb$4.cn("overflowXAuto", [` { overflow-x: auto; }`]),
  overflowYAuto: cssb$4.cn("overflowYAuto", [` { overflow-y: auto; }`]),
  overflowAuto: cssb$4.cn("overflowAuto", [` { overflow: auto; }`]),
  overflowHidden: cssb$4.cn("overflowHidden", [` { overflow: hidden; }`]),
  /** hover utils */
  hoverParent: cnHoverParent,
  hoverTarget: cnHoverTarget,
  hoverTargetInverse: cnHoverTargetInverse,
  /** debug utils */
  debug1pxSolidRed: cssb$4.cn("debug1pxSolidRed", [` { border: 1px solid red; }`]),
  /** Colours */
  inverted: cssb$4.cn("inverted", [` { color: ${cssVars.bg} ; background: ${cssVars.fg}; }`]),
  bg2: cssb$4.cn("bg2", [` { background-color: ${cssVars.bg2}; }`]),
  bg: cssb$4.cn("bg", [` { background-color: ${cssVars.bg}; }`]),
  /** Text and text layouting */
  textAlignCenter: cssb$4.cn("textAlignCenter", [` { text-align: center; }`]),
  textAlignRight: cssb$4.cn("textAlignRight", [` { text-align: right; }`]),
  textAlignLeft: cssb$4.cn("textAlignLeft", [` { text-align: left; }`]),
  pre: cssb$4.cn("pre", [` { white-space: pre; }`]),
  preWrap: cssb$4.cn("preWrap", [` { white-space: pre-wrap; }`]),
  noWrap: cssb$4.cn("noWrap", [` { white-space: nowrap; }`]),
  handleLongWords: cssb$4.cn("handleLongWords", [` { overflow-wrap: anywhere; word-break: normal; }`]),
  strikethrough: cssb$4.cn("strikethrough", [` { text-decoration: line-through; text-decoration-color: currentColor; }`]),
  // This looks horribe though
  // truncated: cssb.cn("truncated", [` { text-overflow: ellipsis; white-space: nowrap; overflow: hidden; }`]),
  truncated: cssb$4.cn("truncated", [` { white-space: nowrap; overflow: hidden; }`]),
  mediumFont: cssb$4.cn("mediumFont", [` { font-size: ${cssVars.mediumText}; }`]),
  normalFont: cssb$4.cn("normalFont", [` { font-size: ${cssVars.normalText}; }`]),
  smallFont: cssb$4.cn("smallFont", [` { font-size: ${cssVars.smallText}; }`])
});
const cssb$3 = newCssBuilder();
const PX = 10001;
const EM = 20001;
const PERCENT = 30001;
const REM = 50001;
const CH = 50001;
const NA = 40001;
function getUnits(num) {
  switch (num) {
    case PX:
      return "px";
    case EM:
      return "em";
    case PERCENT:
      return "%";
    case REM:
      return "rem";
    case CH:
      return "ch";
    default:
      return "px";
  }
}
function getSize(num, units) {
  return units === NA ? "" : num + getUnits(units);
}
function imSize(c, width, wType, height, hType) {
  let size = imGet(c, imSize);
  if (size === void 0) {
    size = imSet(c, { width: 0, wType: NA, height: 0, hType: NA });
  }
  if (size.width !== width || size.wType !== wType) {
    size.width = width;
    size.wType = wType;
    elSetStyle(c, "minWidth", getSize(width, wType));
    elSetStyle(c, "maxWidth", getSize(width, wType));
  }
  if (size.height !== height || size.hType !== hType) {
    size.height = height;
    size.hType = hType;
    elSetStyle(c, "minHeight", getSize(height, hType));
    elSetStyle(c, "maxHeight", getSize(height, hType));
  }
  return size;
}
function imOpacity(c, val) {
  let lastVal = imGet(c, inlineTypeId(imOpacity));
  if (lastVal !== val) {
    imSet(c, val);
    elSetStyle(c, "opacity", "" + val);
  }
}
function newPaddingState() {
  return {
    left: 0,
    leftType: NA,
    right: 0,
    rightType: NA,
    top: 0,
    topType: NA,
    bottom: 0,
    bottomType: NA
  };
}
function imPadding(c, left, leftType, right, rightType, top, topType, bottom, bottomType) {
  let val = imGet(c, newPaddingState);
  if (val === void 0) val = imSet(c, newPaddingState());
  if (val.left !== left || val.leftType !== leftType) {
    val.left = left;
    val.leftType = leftType;
    elSetStyle(c, "paddingLeft", getSize(left, leftType));
  }
  if (val.right !== right || val.rightType !== rightType) {
    val.right = right;
    val.rightType = rightType;
    elSetStyle(c, "paddingRight", getSize(right, rightType));
  }
  if (val.top !== top || val.topType !== topType) {
    val.top = top;
    val.topType = topType;
    elSetStyle(c, "paddingTop", getSize(top, topType));
  }
  if (val.bottom !== bottom || val.bottomType !== bottomType) {
    val.bottom = bottom;
    val.bottomType = bottomType;
    elSetStyle(c, "paddingBottom", getSize(bottom, bottomType));
  }
}
function imRelative(c) {
  if (isFirstishRender(c)) {
    elSetClass(c, cn.relative);
  }
}
function imBg(c, colour) {
  if (imMemo(c, colour)) {
    elSetStyle(c, "backgroundColor", colour);
  }
}
const BLOCK = 1;
const INLINE_BLOCK = 2;
const INLINE = 3;
const ROW = 4;
const ROW_REVERSE = 5;
const COL = 6;
const COL_REVERSE = 7;
const TABLE = 8;
const TABLE_ROW = 9;
const TABLE_CELL = 10;
function imLayout(c, type) {
  const root = imElBegin(c, EL_DIV);
  if (imMemo(c, type)) {
    elSetClass(c, cn.inlineBlock, type === INLINE_BLOCK);
    elSetClass(c, cn.inline, type === INLINE);
    elSetClass(c, cn.row, type === ROW);
    elSetClass(c, cn.rowReverse, type === ROW_REVERSE);
    elSetClass(c, cn.col, type === COL);
    elSetClass(c, cn.colReverse, type === COL_REVERSE);
    elSetClass(c, cn.table, type === TABLE);
    elSetClass(c, cn.tableRow, type === TABLE_ROW);
    elSetClass(c, cn.tableCell, type === TABLE_CELL);
  }
  return root.root;
}
function imPre(c) {
  if (!isFirstishRender(c)) {
    elSetClass(c, cn.pre);
  }
}
function imNoWrap(c) {
  if (!isFirstishRender(c)) {
    elSetClass(c, cn.noWrap);
  }
}
function imLayoutEnd(c) {
  imElEnd(c, EL_DIV);
}
function imFlex(c, ratio = 1) {
  if (imMemo(c, ratio)) {
    elSetStyle(c, "flex", "" + ratio);
    elSetStyle(c, "minWidth", "0");
    elSetStyle(c, "minHeight", "0");
  }
}
function imGap(c, val = 0, units) {
  const valChanged = imMemo(c, val);
  const unitsChanged = imMemo(c, units);
  if (valChanged || unitsChanged) {
    elSetStyle(c, "gap", getSize(val, units));
  }
}
const NONE = 0;
const CENTER = 1;
const LEFT = 2;
const RIGHT = 3;
const STRETCH = 4;
function getAlignment(alignment) {
  switch (alignment) {
    case NONE:
      return "";
    case CENTER:
      return "center";
    case LEFT:
      return "left";
    case RIGHT:
      return "right";
    case STRETCH:
      return "stretch";
  }
  return "";
}
function imAlign(c, alignment = CENTER) {
  if (imMemo(c, alignment)) {
    elSetStyle(c, "alignItems", getAlignment(alignment));
  }
}
function imJustify(c, alignment = CENTER) {
  if (imMemo(c, alignment)) {
    elSetStyle(c, "justifyContent", getAlignment(alignment));
  }
}
const cnButton = (() => {
  const transiton = `0.1s linear`;
  return cssb$3.cn(`button`, [
    ` { cursor: pointer; background-color: ${cssVars.bg}; color: ${cssVars.fg}; transition: background-color ${transiton}, color ${transiton}; }`,
    `:hover { background-color: ${cssVars.fg}; color: ${cssVars.bg}; }`
  ]);
})();
function imButton(c) {
  if (isFirstishRender(c)) elSetClass(c, cnButton);
}
function imScrollOverflow(c, vScroll = true, hScroll = false) {
  if (imMemo(c, vScroll)) {
    elSetClass(c, cn.overflowYAuto, vScroll);
  }
  if (imMemo(c, hScroll)) {
    elSetClass(c, cn.overflowXAuto, hScroll);
  }
}
function imFixed(c, top, topType, left, leftType, bottom, bottomType, right, rightType) {
  if (isFirstishRender(c)) {
    elSetClass(c, cn.fixed);
  }
  imOffsets(
    c,
    top,
    topType,
    left,
    leftType,
    bottom,
    bottomType,
    right,
    rightType
  );
}
function imOffsets(c, top, topType, left, leftType, bottom, bottomType, right, rightType) {
  let val = imGet(c, newPaddingState);
  if (val === void 0) val = imSet(c, newPaddingState());
  if (val.left !== left || val.leftType !== leftType) {
    val.left = left;
    val.leftType = leftType;
    elSetStyle(c, "left", getSize(left, leftType));
  }
  if (val.right !== right || val.rightType !== rightType) {
    val.right = right;
    val.rightType = rightType;
    elSetStyle(c, "right", getSize(right, rightType));
  }
  if (val.top !== top || val.topType !== topType) {
    val.top = top;
    val.topType = topType;
    elSetStyle(c, "top", getSize(top, topType));
  }
  if (val.bottom !== bottom || val.bottomType !== bottomType) {
    val.bottom = bottom;
    val.bottomType = bottomType;
    elSetStyle(c, "bottom", getSize(bottom, bottomType));
  }
}
function imAbsolute(c, left, leftType, right, rightType, top, topType, bottom, bottomType) {
  if (isFirstishRender(c)) {
    elSetClass(c, cn.absolute);
  }
  imOffsets(
    c,
    top,
    topType,
    left,
    leftType,
    bottom,
    bottomType,
    right,
    rightType
  );
}
function setInputValue(el, text) {
  if (
    // performance speedup, and required to be able to select text
    el.value !== text
  ) {
    const { selectionStart, selectionEnd } = el;
    el.value = text;
    el.selectionStart = selectionStart;
    el.selectionEnd = selectionEnd;
  }
}
function isEditingTextSomewhereInDocument() {
  var _a;
  const type = (_a = document.activeElement) == null ? void 0 : _a.nodeName;
  if (type) {
    return stringsAreEqual2Versions(type, "textarea", "TEXTAREA") || stringsAreEqual2Versions(type, "input", "INPUT");
  }
  return false;
}
function stringsAreEqual2Versions(val, lowercase, uppercase) {
  if (val.length !== lowercase.length) return false;
  for (let i = 0; i < lowercase.length; i++) {
    if (val[i] !== lowercase[i] && val[i] !== uppercase[i]) return false;
  }
  return true;
}
const EXTENT_VERTICAL = 1 << 2;
const EXTENT_START = 1 << 3;
const EXTENT_END = 1 << 4;
function getScrollVH(scrollParent, scrollTo, verticalOffset = null, horizontalOffset = null) {
  let scrollLeft = scrollParent.scrollLeft;
  let scrollTop = scrollParent.scrollTop;
  if (horizontalOffset !== null) {
    const scrollOffset = horizontalOffset * scrollParent.offsetWidth;
    const elementWidthOffset = horizontalOffset * scrollTo.getBoundingClientRect().width;
    const scrollToElOffsetLeft = scrollTo.offsetLeft - scrollParent.offsetLeft;
    scrollLeft = scrollToElOffsetLeft - scrollOffset + elementWidthOffset;
  }
  if (verticalOffset !== null) {
    const scrollOffset = verticalOffset * scrollParent.offsetHeight;
    const elementHeightOffset = verticalOffset * scrollTo.getBoundingClientRect().height;
    const scrollToElOffsetTop = scrollTo.offsetTop - scrollParent.offsetTop;
    scrollTop = scrollToElOffsetTop - scrollOffset + elementHeightOffset;
  }
  return { scrollTop, scrollLeft };
}
function getElementExtentNormalized(scrollParent, scrollTo, flags = EXTENT_VERTICAL | EXTENT_START) {
  let result;
  if ((flags & EXTENT_VERTICAL) !== 0) {
    const scrollOffset = scrollTo.offsetTop - scrollParent.scrollTop - scrollParent.offsetTop;
    if (flags & EXTENT_END) {
      result = (scrollOffset + scrollTo.getBoundingClientRect().height) / scrollParent.offsetHeight;
    } else {
      result = scrollOffset / scrollParent.offsetHeight;
    }
  } else {
    const scrollOffset = scrollTo.offsetLeft - scrollParent.scrollLeft - scrollParent.offsetLeft;
    if ((flags & EXTENT_END) !== 0) {
      result = (scrollOffset + scrollTo.getBoundingClientRect().width) / scrollParent.offsetWidth;
    } else {
      result = scrollOffset / scrollParent.offsetWidth;
    }
  }
  return result;
}
function newScrollContainer() {
  return {
    root: null,
    isScrolling: false,
    smoothScroll: false,
    lastScrollTop: -1,
    lastScrollTopStableFrames: 0
  };
}
function startScrolling(sc, smoothScroll) {
  sc.isScrolling = true;
  sc.smoothScroll = smoothScroll;
  sc.lastScrollTopStableFrames = 0;
  sc.lastScrollTop = -1;
}
function imScrollContainerBegin(c, sc, orientation = COL) {
  const scrollParent = imLayout(c, orientation);
  imFlex(c);
  imScrollOverflow(c, orientation === COL, orientation === ROW);
  sc.root = scrollParent;
  return scrollParent;
}
function scrollToItem(c, l, root) {
  const scrollParent = l.root;
  if (!scrollParent) return;
  if (!l.isScrolling) return;
  if (root.parentNode === null) return;
  if (l.lastScrollTopStableFrames > 10) {
    l.isScrolling = false;
    return;
  }
  const { scrollTop } = getScrollVH(
    scrollParent,
    root,
    0.5,
    null
  );
  const currentScrollTop = scrollParent.scrollTop;
  if (Math.abs(scrollTop - scrollParent.scrollTop) < 0.1) {
    l.isScrolling = false;
  } else {
    if (l.smoothScroll) {
      scrollParent.scrollTop = lerp(currentScrollTop, scrollTop, 20 * getDeltaTimeSeconds(c));
    } else {
      scrollParent.scrollTop = scrollTop;
    }
  }
  if (l.lastScrollTop !== currentScrollTop) {
    l.lastScrollTop = currentScrollTop;
    l.lastScrollTopStableFrames = 0;
  }
  l.lastScrollTopStableFrames += 1;
}
function lerp(a, b, t) {
  if (t > 1) t = 1;
  if (t < 0) t = 0;
  return a + (b - a) * t;
}
const cssb$2 = newCssBuilder();
const cssVarsApp = {
  bgInProgress: "var(--bgInProgress)",
  fgInProgress: "var(--fgInProgress)",
  bgEditing: "var(--bgEditing)",
  bgColor: "var(--bgColor)",
  bgColorFocus: "var(--bgColorFocus)",
  bgColorFocus2: "var(--bgColorFocus2)",
  fgColor: "var(--fgColor)",
  unfocusTextColor: "var(--unfocusTextColor)",
  focusedTreePathWidth: "var(--focusedTreePathWidth)",
  unfocusedTreePathWidth: "var(--unfocusedTreePathWidth)"
};
const normalStyle = ` 
font-family: Source Code Pro, monospace; 
font-size: ${cssVars.normalText}; 
color: ${cssVars.fg}; 
background: ${cssVars.bg}; 
font-size: 18px; `;
const lightTheme = {
  bgInProgress: newColor(1, 0, 0, 0.1),
  fgInProgress: newColorFromHex("#FFF"),
  bgEditing: newColorFromHex("#F00"),
  bgColor: newColorFromHex("#FFFFFF"),
  bgColorFocus: newColorFromHex("#CCC"),
  bgColorFocus2: newColorFromHex("#F2F2F2"),
  fgColor: newColorFromHex("#000"),
  unfocusTextColor: newColorFromHex("#A0A0A0"),
  focusedTreePathWidth: "4px",
  unfocusedTreePathWidth: "1px"
};
const darkTheme = {
  bgInProgress: newColor(1, 0, 0, 0.1),
  fgInProgress: newColorFromHex("#FFF"),
  bgEditing: newColorFromHex("#F00"),
  bgColor: newColorFromHex("#000"),
  bgColorFocus: newColorFromHex("#333"),
  bgColorFocus2: newColorFromHex("#222"),
  fgColor: newColorFromHex("#DDDDDD"),
  unfocusTextColor: newColorFromHex("#707070"),
  focusedTreePathWidth: "4px",
  unfocusedTreePathWidth: "1px"
};
let currentAppTheme = lightTheme;
function setAppTheme(theme) {
  setCssVars({
    ...defaultCoreTheme,
    fg: theme.fgColor,
    fg2: theme.bgColorFocus2,
    mg: theme.unfocusTextColor,
    bg2: theme.bgColorFocus,
    bg: theme.bgColor
  });
  currentAppTheme = theme;
  setCssVars(currentAppTheme);
}
cssb$2.s(` 

body { ${normalStyle} }

h4, h3, h2, h1 {
    margin: 0;
}

`);
const cnApp = {
  b: cssb$2.cn("b", [` { font-weight: bold; } `]),
  normal: cssb$2.cn("normal", [` {
${normalStyle}
}`]),
  padded: cssb$2.cn("padded", [` { padding: 5px }`]),
  gap5: cssb$2.cn("gap5", [` { gap: 5px; }`]),
  defocusedText: cssb$2.cn("defocusedText", [` { color: ${cssVars.mg}; }`]),
  bgFocus: cssb$2.cn("bgFocus", [` { background-color: ${cssVars.bg2}; }`]),
  border1Solid: cssb$2.cn("border1Solid", [`{ border: 1px solid ${cssVars.fg}; }`]),
  bold: cssb$2.cn("bold", [` { font-weight: bold; }`]),
  italic: cssb$2.cn("italic", [` { font-style: italic; }`]),
  h1: cssb$2.cn("h1", [` { font-size: 3em; }`]),
  h2: cssb$2.cn("h2", [` { font-size: 2em; }`]),
  h3: cssb$2.cn("h3", [` { font-size: 1.25em; }`])
};
const cssb$1 = newCssBuilder();
const cnHLine = cssb$1.cn("hline", [
  ` { transition: opacity 0.1s linear, height 0.1s linear; }`
]);
const LINE_HORIZONTAL = 1;
const LINE_VERTICAL = 2;
function imLine(c, type, widthPx = 2, visible = true) {
  let height = visible ? widthPx : 0;
  let heightUnit = PX;
  const isH = type === LINE_HORIZONTAL;
  imLayout(c, BLOCK);
  imSize(
    c,
    !isH ? height : 100,
    !isH ? heightUnit : PERCENT,
    isH ? height : 100,
    isH ? heightUnit : PERCENT
  );
  {
    if (isFirstishRender(c)) {
      elSetStyle(c, "backgroundColor", cssVarsApp.fgColor);
      elSetClass(c, cnHLine);
    }
    if (imMemo(c, visible)) {
      elSetStyle(c, "opacity", "" + (visible ? 1 : 0));
    }
  }
  imLayoutEnd(c);
}
function getLineBeforePos(text, pos) {
  const i = getLineStartPos(text, pos);
  return text.substring(i, pos);
}
function getLineStartPos(text, pos) {
  let i = pos;
  if (text[i] === "\r" || text[i] === "\n") {
    i--;
  }
  for (; i > 0; i--) {
    if (text[i] === "\r" || text[i] === "\n") {
      i++;
      break;
    }
  }
  if (pos < i) {
    return 0;
  }
  return i;
}
const cssb = newCssBuilder();
const cnTextAreaRoot = cssb.newClassName("customTextArea");
cssb.s(`
.${cnTextAreaRoot} textarea { 
    white-space: pre-wrap; 
    padding: 5px; 
    caret-color: ${cssVars.fg};
    color: transparent;
}
.${cnTextAreaRoot}:has(textarea:focus), .${cnTextAreaRoot}:has(textarea:hover) { 
    background-color: ${cssVars.bg2};
}
`);
function imTextAreaBegin(c, {
  value,
  isOneLine,
  placeholder = ""
}) {
  let textArea;
  const root = imLayout(c, BLOCK);
  {
    if (isFirstishRender(c)) {
      elSetClass(c, cn.flex1);
      elSetClass(c, cn.row);
      elSetClass(c, cn.h100);
      elSetClass(c, cn.overflowYAuto);
      elSetClass(c, cnTextAreaRoot);
    }
    imLayout(c, BLOCK);
    {
      if (isFirstishRender(c)) {
        elSetClass(c, cn.handleLongWords);
        elSetClass(c, cn.relative);
        elSetClass(c, cn.w100);
        elSetClass(c, cn.hFitContent);
        elSetStyle(c, "minHeight", "100%");
      }
      if (imMemo(c, isOneLine)) {
        elSetClass(c, cn.preWrap, !isOneLine);
        elSetClass(c, cn.pre, !!isOneLine);
        elSetClass(c, cn.overflowHidden, isOneLine);
        elSetClass(c, cn.noWrap, !!isOneLine);
      }
      imLayout(c, INLINE);
      {
        const placeholderChanged = imMemo(c, placeholder);
        const valueChanged = imMemo(c, value);
        if (placeholderChanged || valueChanged) {
          if (!value) {
            elSetTextSafetyRemoved(c, placeholder);
            elSetStyle(c, "color", cssVars.fg2);
          } else {
            elSetTextSafetyRemoved(c, value);
            elSetStyle(c, "color", cssVars.fg);
          }
        }
      }
      imLayoutEnd(c);
      imLayout(c, INLINE);
      {
        if (isFirstishRender(c)) {
          elSetStyle(c, "color", "transparent");
          elSetStyle(c, "userSelect", "none");
          elSetTextSafetyRemoved(c, ".");
        }
      }
      imLayoutEnd(c);
      textArea = imElBegin(c, EL_TEXTAREA).root;
      {
        if (isFirstishRender(c)) {
          elSetAttr(c, "class", [cn.allUnset, cn.absoluteFill, cn.preWrap, cn.w100, cn.h100].join(" "));
          elSetAttr(c, "style", "background-color: transparent; color: transparent; overflow-y: hidden; padding: 0px");
        }
        if (imMemo(c, value)) {
          setInputValue(textArea, value);
        }
      }
    }
  }
  return [root, textArea];
}
function imTextAreaEnd(c) {
  {
    {
      imElEnd(c, EL_TEXTAREA);
    }
    imLayoutEnd(c);
  }
  imLayoutEnd(c);
}
function doExtraTextAreaInputHandling(e, textArea, config) {
  const execCommand = document.execCommand.bind(document);
  const spacesInsteadOfTabs = config.useSpacesInsteadOfTabs ?? false;
  const tabStopSize = config.tabStopSize ?? 4;
  let text = textArea.value;
  const start = textArea.selectionStart;
  const end = textArea.selectionEnd;
  let handled = false;
  const getSpacesToRemove = (col) => {
    if (!config.useSpacesInsteadOfTabs) {
      return 1;
    }
    if (![...col].every((c) => c === " ")) {
      return 1;
    }
    let spacesToRemove = col.length % tabStopSize;
    if (spacesToRemove === 0) {
      spacesToRemove = tabStopSize;
    }
    if (spacesToRemove > col.length) {
      spacesToRemove = col.length;
    }
    return spacesToRemove;
  };
  const getIndentation = (col) => {
    if (!spacesInsteadOfTabs) {
      return "	";
    }
    const numSpaces = tabStopSize - col.length % tabStopSize;
    return " ".repeat(numSpaces);
  };
  if (e.key === "Backspace" && !e.altKey && !e.ctrlKey && !e.shiftKey && !e.metaKey) {
    if (start === end) {
      const col = getLineBeforePos(text, start);
      const spacesToRemove = getSpacesToRemove(col);
      if (spacesToRemove) {
        e.preventDefault();
        for (let i = 0; i < spacesToRemove; i++) {
          execCommand("delete", false, void 0);
          handled = true;
        }
      }
    }
  } else if (e.key === "Tab" && !e.altKey && !e.ctrlKey && !e.metaKey) {
    if (e.shiftKey) {
      e.preventDefault();
      let newStart = start;
      let newEnd = end;
      let i = end;
      while (i >= start) {
        const col = getLineBeforePos(text, i);
        if (col.length === 0) {
          i--;
          continue;
        }
        const numNonWhitespaceAtColStart = col.trimStart().length;
        const pos = i - numNonWhitespaceAtColStart;
        textArea.selectionStart = pos;
        textArea.selectionEnd = pos;
        {
          const col2 = col.substring(0, col.length - numNonWhitespaceAtColStart);
          const spacesToRemove = getSpacesToRemove(col2);
          for (let i2 = 0; i2 < spacesToRemove; i2++) {
            execCommand("delete", false, void 0);
            handled = true;
            newEnd--;
          }
        }
        i -= col.length;
      }
      textArea.selectionStart = newStart;
      textArea.selectionEnd = newEnd;
    } else {
      if (start === end) {
        const col = getLineBeforePos(text, start);
        const indentation = getIndentation(col);
        e.preventDefault();
        execCommand("insertText", false, indentation);
        handled = true;
      } else {
        e.preventDefault();
        let newStart = start;
        let newEnd = end;
        let i = end;
        while (i >= start) {
          const col = getLineBeforePos(text, i);
          if (col.length === 0) {
            i--;
            continue;
          }
          const numNonWhitespaceAtColStart = col.trimStart().length;
          const pos = i - numNonWhitespaceAtColStart;
          const col2 = col.substring(0, col.length - numNonWhitespaceAtColStart);
          const indentation = getIndentation(col2);
          textArea.selectionStart = pos;
          textArea.selectionEnd = pos;
          execCommand("insertText", false, indentation);
          handled = true;
          newEnd += indentation.length;
          i -= col.length;
        }
        textArea.selectionStart = newStart;
        textArea.selectionEnd = newEnd;
      }
    }
  } else if (e.key === "Escape" && !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey && start !== end) {
    handled = true;
    e.stopImmediatePropagation();
    textArea.selectionEnd = textArea.selectionStart;
  }
  return handled;
}
function imB(c) {
  return imElBegin(c, EL_B);
}
function imBEnd(c) {
  return imElEnd(c, EL_B);
}
function imI(c) {
  return imElBegin(c, EL_I);
}
function imIEnd(c) {
  return imElEnd(c, EL_I);
}
const ROW_EXISTS = 0;
const ROW_HIGHLIGHTED = 1;
const ROW_SELECTED = 2;
const ROW_FOCUSED = 3;
const ROW_EDITING = 4;
function getBg(status) {
  switch (status) {
    case ROW_HIGHLIGHTED:
      return cssVarsApp.bgColorFocus2;
    case ROW_SELECTED:
      return cssVarsApp.bgColorFocus2;
    case ROW_FOCUSED:
      return cssVarsApp.bgColorFocus;
    case ROW_EDITING:
      return cssVarsApp.bgColorFocus;
  }
  return "";
}
function getRowStatus(highlighted, focused, isEditing = false) {
  let status = ROW_EXISTS;
  if (highlighted) {
    status = ROW_SELECTED;
    if (focused) {
      status = ROW_FOCUSED;
      if (isEditing) {
        status = ROW_EDITING;
      }
    }
  }
  return status;
}
function imListRowBegin(c, highlighted, focused, isEditing = false) {
  const status = getRowStatus(highlighted, focused, isEditing);
  const root = imLayout(c, ROW);
  {
    imListCursorBg(c, status);
    imLayout(c, BLOCK);
    imSize(c, 10, PX, 0, NA);
    {
      imListCursorColor(c, status);
    }
    imLayoutEnd(c);
  }
  return root;
}
function imListCursorBg(c, status) {
  const statusChanged = imMemo(c, status);
  if (statusChanged) {
    elSetStyle(c, "backgroundColor", getBg(status));
  }
}
function imListCursorColor(c, status) {
  const statusChanged = imMemo(c, status);
  if (statusChanged) {
    elSetStyle(
      c,
      "backgroundColor",
      status === ROW_FOCUSED ? cssVarsApp.fgColor : status === ROW_EDITING ? cssVarsApp.bgEditing : ""
    );
  }
}
function imListRowEnd(c) {
  {
    imLayout(c, BLOCK);
    imSize(c, 10, PX, 0, NA);
    imLayoutEnd(c);
  }
  imLayoutEnd(c);
}
function imEndListRowNoPadding(c) {
  imLayoutEnd(c);
}
function imListRowCellStyle(c) {
  if (isFirstishRender(c)) {
    elSetStyle(c, "minHeight", "1em");
  }
  imPadding(c, 8, PX, 3, PX, 3, PX, 3, PX);
}
function filterInPlace(arr, predicate) {
  let i2 = 0;
  for (let i = 0; i < arr.length; i++) {
    if (predicate(arr[i], i, i2)) arr[i2++] = arr[i];
  }
  arr.length = i2;
}
function boundsCheck(arr, i) {
  return i >= 0 && i < arr.length;
}
function findLastIndex(arr, fn, start = -1) {
  if (start < 0) {
    start = arr.length + start;
  }
  for (let i = start; i >= 0; i--) {
    if (fn(arr[i])) {
      return i;
    }
  }
  return -1;
}
function arrayAt(arr, i) {
  return arr[i];
}
function get(arr, i) {
  let result = void 0;
  if (i < arr.length) result = arr[i];
  return result;
}
function getWrappedIdx(i, len) {
  if (len === 0) return -1;
  if (i >= len) return i % len;
  if (i < 0) {
    const unflipped = -(i + 1) % len;
    return len - 1 - unflipped;
  }
  return i;
}
function newListPosition() {
  return { idx: 0 };
}
function clampedListIdx(idx, len) {
  return clampedListIdxRange(idx, 0, len);
}
function clampedListIdxRange(idx, min, maxEx) {
  if (idx < min) idx = min;
  if (idx >= maxEx) idx = maxEx - 1;
  return idx;
}
const AXIS_VERTICAL = 0;
const AXIS_HORIZONTAL = 1;
const AXIS_FLAG_REPEATING = 1 << 0;
const AXIS_FLAG_BYPASS_TEXT_AREA = 1 << 1;
function getNavigableListInput(ctx, idx, lo, hi, axis = AXIS_VERTICAL, flags = 0) {
  if (hi <= lo) return null;
  if (ctx.handled) return null;
  const keyboard = ctx.keyboard;
  const oldIdx = idx;
  let newIdx;
  let hdcFlags = REPEAT | ANY_MODIFIERS;
  if (flags & AXIS_FLAG_BYPASS_TEXT_AREA) {
    flags |= BYPASS_TEXT_AREA;
  }
  if (axis === AXIS_VERTICAL) {
    if (hasDiscoverableCommand(ctx, keyboard.upKey, "Up", hdcFlags)) newIdx = oldIdx - 1;
    if (hasDiscoverableCommand(ctx, keyboard.downKey, "Down", hdcFlags)) newIdx = oldIdx + 1;
  } else if (axis === AXIS_HORIZONTAL) {
    if (hasDiscoverableCommand(ctx, keyboard.leftKey, "Left", hdcFlags)) newIdx = oldIdx - 1;
    if (hasDiscoverableCommand(ctx, keyboard.rightKey, "Right", hdcFlags)) newIdx = oldIdx + 1;
  }
  if (keyboard.pageUpKey.pressed) newIdx = oldIdx - 10;
  if (keyboard.pageDownKey.pressed) newIdx = oldIdx + 10;
  if (!isEditingTextSomewhereInDocument()) {
    if (keyboard.homeKey.pressed) newIdx = lo;
    if (keyboard.endKey.pressed) newIdx = hi - 1;
  }
  if (newIdx === void 0) return null;
  if (flags & AXIS_FLAG_REPEATING) {
    newIdx = lo + getWrappedIdx(newIdx, hi - lo);
  } else {
    newIdx = clampedListIdxRange(newIdx, lo, hi);
  }
  ctx.handled = true;
  return { newIdx };
}
function newNavigabeListState() {
  return {
    scrollContainer: null,
    viewHasFocus: false,
    isEditing: false,
    currentListIdx: 0,
    i: -1,
    numItems: 0,
    itemSelected: false,
    isMassiveAhhList: false
  };
}
function imNavListNextItem(list) {
  list.i++;
  list.itemSelected = list.i === list.currentListIdx;
}
function imNavListNextItemArray(list, items) {
  list.i++;
  list.itemSelected = list.i === list.currentListIdx;
  let result = list.i < items.length;
  return result;
}
function navListNextItemSlice(list, start, end) {
  if (list.i === -1) {
    list.i = start;
  } else {
    list.i++;
  }
  let result = list.i < end;
  if (result) {
    list.itemSelected = list.i === list.currentListIdx;
  }
  return result;
}
function imNavListBegin(c, scrollContainer, listPositionIdx, viewHasFocus, isEditing = false, row = false) {
  let s = imGet(c, newNavigabeListState);
  if (!s) s = imSet(c, newNavigabeListState());
  if (s.currentListIdx !== listPositionIdx) {
    s.currentListIdx = listPositionIdx;
    startScrolling(scrollContainer, scrollContainer.smoothScroll);
  }
  s.scrollContainer = scrollContainer;
  s.viewHasFocus = viewHasFocus;
  s.isEditing = isEditing;
  s.i = -1;
  imScrollContainerBegin(c, s.scrollContainer, row ? ROW : COL);
  {
    imFor(c);
  }
  return s;
}
function imNavListEnd(c, _list) {
  _list.numItems = _list.i + 1;
  {
    imForEnd(c);
  }
  imLayoutEnd(c);
}
function imNavListRowBegin(c, list, highlighted = false) {
  const itemSelected = list ? list.itemSelected : false;
  const root = imListRowBegin(
    c,
    itemSelected || highlighted,
    list ? itemSelected && list.viewHasFocus : false,
    list ? itemSelected && list.isEditing : false
  );
  if (itemSelected && list !== null) {
    assert(!!list.scrollContainer);
    scrollToItem(c, list.scrollContainer, root);
  }
  return root;
}
function imNavListRowEnd(c) {
  imListRowEnd(c);
}
function newViewsList() {
  return { imLength: 0, views: [], idx: 0 };
}
function newFocusRef() {
  return { focused: null };
}
function imViewsList(c, focusRef) {
  let s = imGet(c, newViewsList);
  if (!s) s = imSet(c, newViewsList());
  s.idx = clampedListIdx(s.idx, s.imLength);
  assert(s.imLength <= s.views.length);
  if (s.imLength > 0) {
    if (s.views[s.idx] !== focusRef.focused) {
      let idx = -1;
      for (let i = 0; i < s.views.length; i++) {
        if (s.views[i].focusRef === focusRef.focused) {
          idx = i;
          break;
        }
      }
      if (idx === -1) {
        idx = 0;
      }
      s.idx = idx;
      focusRef.focused = s.views[idx].focusRef;
    }
  }
  s.imLength = 0;
  return s;
}
function addView(list, focusRef, name) {
  assert(list.imLength <= list.views.length);
  if (list.imLength === list.views.length) {
    list.views.push({ focusRef: null, name: "" });
  }
  list.views[list.imLength].focusRef = focusRef;
  list.views[list.imLength].name = name;
  list.imLength++;
}
function getTabInput(ctx, prevCommand, nextCommand) {
  const keyboard = ctx.keyboard;
  if (prevCommand !== null) {
    if (hasDiscoverableCommand(ctx, keyboard.tabKey, prevCommand, REPEAT | SHIFT)) return -1;
  }
  if (nextCommand !== null) {
    if (hasDiscoverableCommand(ctx, keyboard.tabKey, nextCommand, REPEAT)) return 1;
  }
  return 0;
}
function getLayersString(layers) {
  if (layers.length === 0) {
    throw Error("Can't serialize empty layers. ");
  }
  const rows = layers[0].data.length;
  const cols = layers[0].data[0].length;
  const lines = [];
  for (let i = 0; i < rows; i++) {
    const rowStringBuilder = [];
    for (let j = 0; j < cols; j++) {
      let c = " ";
      for (let lIdx = layers.length - 1; lIdx >= 0; lIdx--) {
        const l = layers[lIdx];
        const lc = l.data[i][j];
        if (lc !== " ") {
          c = lc;
          break;
        }
      }
      rowStringBuilder.push(c);
    }
    lines.push(rowStringBuilder.join("").trimEnd());
  }
  for (let i = lines.length - 1; i >= 0; i--) {
    const line = lines[i];
    if (line.trim() !== "") {
      break;
    }
    lines.pop();
  }
  return lines.join("\n");
}
function newParser(text) {
  return { text, i: 0, errorPos: 0 };
}
function parserGet(p) {
  return p.i >= p.text.length ? "" : p.text[p.i];
}
function revertParser(p, oldPos) {
  p.errorPos = p.i;
  p.i = oldPos;
}
function parserAdvance(p) {
  if (p.i < p.text.length) p.i++;
}
function isWhiteSpace(c) {
  if (c.length === 0) return false;
  return c.trim().length === 0;
}
function isDigit(c) {
  if (c.length === 0) return false;
  const code = c.charCodeAt(0);
  return code >= 48 && code <= 57;
}
function parserAdvanceWhitespace(p) {
  while (isWhiteSpace(parserGet(p))) parserAdvance(p);
}
function parserParseInt(p) {
  let last = p.i;
  let start = p.i;
  while (isDigit(parserGet(p))) parserAdvance(p);
  if (start === p.i) {
    revertParser(p, last);
    return null;
  }
  const substr = p.text.substring(start, p.i);
  return parseInt(substr);
}
function parserParseDelimter(p, delimiters) {
  if (delimiters.includes(parserGet(p))) {
    parserAdvance(p);
    return true;
  }
  return false;
}
function parserParseKeyword(p, keyword) {
  let last = p.i;
  let i = 0;
  for (; i < keyword.length; i++) {
    if (parserGet(p) !== keyword[i]) break;
    parserAdvance(p);
  }
  if (i !== keyword.length) {
    revertParser(p, last);
    return false;
  }
  return true;
}
const DAYS_OF_THE_WEEK_ABBREVIATED = [
  "Sun",
  "Mon",
  "Tue",
  "Wed",
  "Thu",
  "Fri",
  "Sat"
];
function formatDateTime(date, seperator, dayOfTheWeek = false, useSeconds = false) {
  const dateFormatted = formatDate(date, dayOfTheWeek);
  const timeFormatted = formatTime(date, seperator, useSeconds);
  return `${dateFormatted} ${timeFormatted}`;
}
function formatTimeForInput(date, seperator = ":", useSeconds = false) {
  if (!date) {
    return "";
  }
  return formatTime(date, seperator, useSeconds);
}
function formatTime(date, seperator = ":", useSeconds = false) {
  if (!date) {
    return `--${seperator}--${useSeconds ? seperator + "--" : ""} --`;
  }
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  const hoursStr = pad2((hours - 1) % 12 + 1);
  const minStr = pad2(minutes);
  const secondsStr = useSeconds ? `${seperator}${pad2(seconds)}` : "";
  const amPmStr = hours < 12 ? "am" : "pm";
  return `${hoursStr}${seperator}${minStr}${secondsStr} ${amPmStr}`;
}
function formatDate(date, dayOfTheWeek = false) {
  if (!date) {
    const dayOfTheWeekStr2 = !dayOfTheWeek ? "" : "--- ";
    return `${dayOfTheWeekStr2}${getDatePlaceholder("--", "--", "----")}`;
  }
  const dd = date.getDate();
  const mm = date.getMonth() + 1;
  const yyyy = date.getFullYear();
  const dayOfTheWeekStr = !dayOfTheWeek ? "" : DAYS_OF_THE_WEEK_ABBREVIATED[date.getDay()] + " ";
  return `${dayOfTheWeekStr}${pad2(dd)}/${pad2(mm)}/${yyyy}`;
}
function isSameDate(a, b) {
  return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
}
function clampDate(date, lowerBound, upperBound) {
  if (lowerBound && upperBound) {
    assert(lowerBound.getTime() <= upperBound.getTime());
  }
  date = new Date(date);
  if (upperBound && date.getTime() > upperBound.getTime()) {
    date.setTime(upperBound.getTime() - 1);
  }
  if (lowerBound && date.getTime() < lowerBound.getTime()) {
    date.setTime(lowerBound.getTime() + 1);
  }
  return date;
}
function cloneDate(date) {
  if (date === null) return null;
  return new Date(date);
}
function pad2(num) {
  return num < 10 ? "0" + num : "" + num;
}
function truncate(str, len) {
  if (str.length > len) {
    return str.substring(0, len - 3) + "...";
  }
  return str;
}
function parseTimeInput(str, today) {
  const p = newParser(str);
  const hm = { hours: 0, minutes: 0 };
  parserAdvanceWhitespace(p);
  let hours = parserParseInt(p);
  if (hours === null) return [hm, "Missing hours"];
  let minutes = 0;
  parserAdvanceWhitespace(p);
  if (parserParseDelimter(p, ":")) {
    parserAdvanceWhitespace(p);
    const minutesMaybe = parserParseInt(p);
    if (minutesMaybe !== null) minutes = minutesMaybe;
  } else if (!parserAtEnd(p)) {
    return [hm, "Expected : seperator here"];
  }
  parserAdvanceWhitespace(p);
  let isAm = parserParseKeyword(p, "am") || parserParseKeyword(p, "AM");
  let isPm = !isAm && (parserParseKeyword(p, "pm") || parserParseKeyword(p, "PM"));
  if (!isAm && !isPm) {
    isAm = today.getHours() < 12;
    isPm = !isAm;
  }
  if (hours < 12 && isPm) hours += 12;
  return [{ hours, minutes }, null];
}
function parserAtEnd(p) {
  return parserGet(p).length === 0;
}
function parseDurationInput(str) {
  const p = newParser(str);
  let duration = 0;
  let entries = 0;
  while (!parserAtEnd(p)) {
    parserAdvanceWhitespace(p);
    let time = parserParseInt(p);
    if (time === null) return [0, "Expected whole number"];
    parserAdvanceWhitespace(p);
    const isH = parserParseKeyword(p, "h");
    const isM = !isH && parserParseKeyword(p, "m");
    if (!isH && !isM) {
      if (entries === 0 && parserAtEnd(p)) {
        if (time > 12) {
          return [time * ONE_MINUTE, null];
        }
        return [time * ONE_HOUR, null];
      }
      return [0, "Expected 'h' or 'm'"];
    }
    if (isH) {
      duration += time * ONE_HOUR;
    } else if (isM) {
      duration += time * ONE_MINUTE;
    } else {
      assert(false);
    }
    entries++;
  }
  if (entries === 0) {
    return [0, "Missing input"];
  }
  return [duration, null];
}
function dateSetLocalTime(date, time) {
  date.setHours(time.hours);
  date.setMinutes(time.minutes);
  date.setSeconds(0, 0);
}
function floorDateLocalTime(date) {
  date.setHours(0, 0, 0, 0);
}
function floorDateToWeekLocalTime(date) {
  floorDateLocalTime(date);
  const dayOfWeek = date.getDay();
  addDays(date, -dayOfWeek);
}
function addDays(date, days) {
  date.setDate(date.getDate() + days);
}
function addMinutes(date, minutes) {
  date.setMinutes(date.getMinutes() + minutes);
}
function roundToNearestMinutes(date, minuteSnap) {
  date.setMinutes(Math.floor(date.getMinutes() / minuteSnap) * minuteSnap);
}
function formatDurationAsHours(ms) {
  const hours = Math.floor(ms / 1e3 / 60 / 60);
  const minutes = Math.floor(ms / 1e3 / 60) % 60;
  if (hours === 0) {
    return minutes + "m";
  }
  return hours + "h" + pad2(minutes) + "m";
}
function formatDuration(ms, unitLimit = -1) {
  const seconds = Math.floor(ms / 1e3) % 60;
  const minutes = Math.floor(ms / 1e3 / 60) % 60;
  const hours = Math.floor(ms / 1e3 / 60 / 60) % 24;
  const days = Math.floor(ms / 1e3 / 60 / 60 / 24);
  if (ms < 1e3) {
    return `${ms} ms`;
  }
  const str = [];
  if (days) {
    str.push(`${days} d`);
  }
  if (hours) {
    str.push(`${hours} h`);
  }
  if (minutes) {
    str.push(`${minutes} m`);
  }
  if (seconds) {
    str.push(`${seconds} s`);
  }
  if (unitLimit !== -1) {
    return str.slice(0, unitLimit).join(", ");
  }
  return str.join(", ");
}
function getTimestamp(date) {
  return date.toISOString();
}
function parseDateSafe(timestamp) {
  const d = new Date(timestamp);
  if (!isValidDate(d)) {
    return null;
  }
  return d;
}
function isValidDate(d) {
  return d instanceof Date && !isNaN(d.getTime());
}
const ONE_SECOND = 1e3;
const ONE_MINUTE = ONE_SECOND * 60;
const ONE_HOUR = 60 * ONE_MINUTE;
let mmDdYyyyOrder = null;
function inferMmDdYyyyOrder() {
  if (mmDdYyyyOrder !== null) return mmDdYyyyOrder;
  const order = [0, 1, 2];
  const date = /* @__PURE__ */ new Date();
  date.setFullYear(2e3);
  date.setMonth(11);
  date.setDate(15);
  const str = date.toLocaleDateString();
  const yearIdx = str.indexOf("2000");
  const monthIdx = str.indexOf("12");
  const dayIdx = str.indexOf("15");
  if (yearIdx === -1 || monthIdx === -1 || dayIdx === -1) {
    throw new Error("The date couldn't be constructed in a predictable manner");
  }
  const parts = [
    [dayIdx, 0],
    [monthIdx, 1],
    [yearIdx, 2]
  ];
  parts.sort((a, b) => a[0] - b[0]);
  for (let i = 0; i < parts.length; i++) {
    order[i] = parts[i][1];
  }
  mmDdYyyyOrder = order;
  return order;
}
function getDatePlaceholder(dayStr = "dd", monthStr = "mm", yearStr = "yyyy") {
  const order = inferMmDdYyyyOrder();
  const sb = [];
  for (let i = 0; i < order.length; i++) {
    const nextSegmentType = order[i];
    switch (nextSegmentType) {
      case 0:
        {
          sb.push(dayStr);
        }
        break;
      case 1:
        {
          sb.push(monthStr);
        }
        break;
      case 2:
        {
          sb.push(yearStr);
        }
        break;
    }
  }
  return sb.join("/");
}
function forEachNode(tree, fn) {
  for (let i = 0; i < tree.nodes.length; i++) {
    const n = tree.nodes[i];
    if (n !== null) {
      fn(n);
    }
  }
}
const ROOT_ID = 0;
const NIL_ID = -1;
function newTreeStore(rootNoteData) {
  const rootNode = {
    id: ROOT_ID,
    parentId: NIL_ID,
    idxInParentList: NIL_ID,
    childIds: [],
    data: rootNoteData
  };
  return {
    nodes: [rootNode]
  };
}
function hasNode(tree, idx) {
  if (idx === -1) {
    return false;
  }
  if (idx < 0 || idx >= tree.nodes.length) {
    return false;
  }
  return !!tree.nodes[idx];
}
function getNode(tree, idx) {
  const data = tree.nodes[idx];
  if (!data) {
    if (data === null) {
      throw new Error("Found tombstone instead of a node at " + idx);
    }
    throw new Error("Node not found: " + idx);
  }
  return data;
}
function getParent(tree, node) {
  const parentIdx = node.parentId;
  const idxInParent = node.idxInParentList;
  if (parentIdx === -1) {
    return void 0;
  }
  const parent = tree.nodes[parentIdx];
  if (parent === null) {
    return void 0;
  }
  if (idxInParent === -1) {
    throw new Error("idxInParent can't be null if parentIdx wasn't -1");
  }
  if (parent.childIds[idxInParent] !== node.id) {
    throw new Error("Node's idxInParent was inconsistent with the parent's list");
  }
  return parent;
}
function getSizeExcludingRoot(tree) {
  return tree.nodes.length - 1;
}
function newTreeNode(data) {
  const node = {
    id: NIL_ID,
    parentId: NIL_ID,
    idxInParentList: -1,
    childIds: [],
    data
  };
  return node;
}
function detatch(tree, node) {
  const parent = getParent(tree, node);
  if (!parent) {
    return;
  }
  const idxInParentList = node.idxInParentList;
  parent.childIds.splice(idxInParentList, 1);
  reindexChildren(tree, parent, idxInParentList);
  node.parentId = NIL_ID;
  node.idxInParentList = -1;
}
function remove(tree, node) {
  if (node.id === -1) {
    return;
  }
  detatch(tree, node);
  tree.nodes[node.id] = null;
  node.id = NIL_ID;
}
function reindexChildren(tree, note, from) {
  for (let i = from; i < note.childIds.length; i++) {
    const child = getNode(tree, note.childIds[i]);
    child.idxInParentList = i;
  }
}
function addAsRoot(tree, node) {
  if (node.id === -1) {
    const idx = getNextAvailableIndex(tree);
    node.id = idx;
    tree.nodes[idx] = node;
    return;
  }
  detatch(tree, node);
}
function getNextAvailableIndex(tree) {
  for (let i = 0; i < tree.nodes.length; i++) {
    if (tree.nodes[i] === null) {
      return i;
    }
  }
  return tree.nodes.length;
}
function addUnder(tree, parent, nodeToAdd) {
  insertAt(tree, parent, nodeToAdd, parent.childIds.length);
}
function addAfter(tree, child, nodeToAdd) {
  const parent = getParent(tree, child);
  if (!parent) {
    throw new Error("Invalid to addAfter a node without a parent");
  }
  insertAt(tree, parent, nodeToAdd, child.idxInParentList + 1);
}
function insertAt(tree, parent, nodeToAdd, idx) {
  addAsRoot(tree, nodeToAdd);
  const nodeToAddIdx = nodeToAdd.id;
  nodeToAdd.parentId = parent.id;
  parent.childIds.splice(idx, 0, nodeToAddIdx);
  reindexChildren(tree, parent, idx);
}
function logTrace(message) {
  console.log(message);
}
function asNull(val) {
  return val === null ? null : void 0;
}
function asString(val) {
  return typeof val === "string" ? val : void 0;
}
function asNumber(val) {
  return typeof val === "number" ? val : void 0;
}
function asBoolean(val) {
  return typeof val === "boolean" ? val : void 0;
}
function asTrue(val) {
  return val === true ? true : void 0;
}
function asObject(val, reinterpretEntriesAsObject = true) {
  if (val != null && val.constructor === Object) {
    return val;
  }
  if (reinterpretEntriesAsObject) {
    const entries = asStringOrNumberEntriesList(val, true, (u) => u);
    if (entries) {
      return Object.fromEntries(entries);
    }
  }
  return void 0;
}
function asArray(val, castFn) {
  if (!Array.isArray(val)) return void 0;
  if (!castFn) return val;
  if (!val.every(castFn)) return void 0;
  return val;
}
function asDate(val) {
  if (typeof val === "string") {
    if (val.length === 24 || val.length === 27) {
      const parsed = new Date(val);
      if (!isNaN(parsed.getTime())) {
        return parsed;
      }
    }
  }
  return void 0;
}
function asStringMap(val, mapFn) {
  return new Map(asStringOrNumberEntriesList(val, true, mapFn));
}
function asStringOrNumberEntriesList(val, stringKeys, mapFn) {
  let arr = asArray(val);
  if (!arr) {
    const obj = asObject(val, false);
    if (obj) {
      arr = Object.entries(obj);
    }
  }
  if (!arr) return void 0;
  {
    const entries = [];
    for (let i = 0; i < arr.length; i++) {
      const entry = asArray(arr[i]);
      if (!entry) return void 0;
      if (entry.length !== 2) return void 0;
      const val2 = mapFn(entry[1]);
      if (val2 === void 0) continue;
      const k = asString(entry[0]);
      if (k === void 0) return void 0;
      entries.push([k, val2]);
    }
    return entries;
  }
}
const NULLABLE = 1 << 0;
function deserializeObjectKey(dst, src, key, flags = 0, rootName = "") {
  const recordValue = src[key];
  if (recordValue === void 0) {
    return;
  }
  const defaultValue = dst[key];
  if (defaultValue == null) {
    throw new Error(`Error deserializing field ${rootName + "." + key}: Default value was ${defaultValue}, we can't infer how to deserialize it. Extra deserialization code required.`);
  }
  let result = void 0;
  if (recordValue == null) {
    if (flags & NULLABLE) {
      result = recordValue;
    } else {
      throw new Error(`Error deserializing field ${rootName + "." + key}: Didn't expect null here`);
    }
  } else if (defaultValue.constructor === Object) {
    const reinterpreted = asObject(recordValue);
    if (reinterpreted === void 0) {
      throw new Error(`Error deserializing field ${rootName + "." + key}: Expected a plain object here`);
    }
    deserializeObject(defaultValue, reinterpreted, rootName + "." + key);
    result = defaultValue;
  } else {
    const isArray = Array.isArray(defaultValue) || Array.isArray(recordValue);
    const isMap = defaultValue instanceof Map;
    const isSet = defaultValue instanceof Set;
    if (isArray || isMap || isSet) {
      throw new Error(`Error deserializing field ${rootName + "." + key}: Got ${isArray ? "an array" : isMap ? "a map" : "a set"} here. We can't infer how to serialize it. Extra deserialization code required.`);
    } else if (defaultValue instanceof Date) {
      result = asDate(recordValue);
    } else if (defaultValue === true || defaultValue === false) {
      result = asBoolean(recordValue);
    } else if (typeof defaultValue === "number") {
      result = asNumber(recordValue);
    } else if (typeof defaultValue === "string") {
      result = asString(recordValue);
    }
  }
  if (result === void 0) {
    throw new Error(`Error deserializing field ${rootName + "." + key}: Couldn't successfully parse this value`);
  }
  dst[key] = result;
  src[key] = void 0;
}
function deserializeObject(dst, src, rootName = "") {
  for (const k in dst) {
    deserializeObjectKey(dst, src, k, 0, rootName);
  }
}
function extractKey(src, key) {
  const val = src[key];
  src[key] = void 0;
  return val;
}
function serializeToJSON(val) {
  const serializable = getJSONSerializable(val);
  return JSON.stringify(serializable);
}
function getJSONSerializable(val) {
  if (val === void 0) {
    throw new Error("undefined values can't be serialized");
  }
  if (Array.isArray(val)) {
    return val.map(getJSONSerializable);
  }
  if (val instanceof Map) {
    const entries = [];
    for (const [k, v] of val) {
      if (v === void 0) continue;
      if (asString(k) === void 0 && asNumber(k) === void 0) {
        throw new Error("Only maps with string or number keys can be serialized");
      }
      entries.push([k, getJSONSerializable(v)]);
    }
    return entries;
  }
  if (val instanceof Set) {
    const entries = [];
    for (const v of val) {
      if (v === void 0) continue;
      entries.push(getJSONSerializable(v));
    }
    return entries;
  }
  if (val != null && val.constructor === Object) {
    const entries = [];
    for (const [kU, v] of Object.entries(val)) {
      if (v === void 0) continue;
      if (!kU.startsWith("_")) {
        entries.push([kU, getJSONSerializable(v)]);
      }
    }
    return Object.fromEntries(entries);
  }
  return val;
}
function newGraphEdge(id, text, thickness) {
  return {
    id,
    text,
    thickness,
    srcNodeId: "",
    dstNodeId: "",
    srcX: 0,
    srcY: 0,
    srcXPivot: 0,
    srcYPivot: 0,
    dstX: 0,
    dstY: 0,
    dstXPivot: 0,
    dstYPivot: 0
  };
}
function newGraphNode(id, text, x, y) {
  return {
    id,
    text,
    x,
    y
  };
}
function newGraphData() {
  return {
    nodes: /* @__PURE__ */ new Map(),
    edges: /* @__PURE__ */ new Map()
  };
}
function asNoteIds(val) {
  return asArray(val, (n) => typeof n === "number");
}
function asNoteTreeGlobalState(val) {
  const stateObj = asObject(val);
  if (stateObj === void 0) throw new Error("Expected an object as input");
  const state2 = newNoteTreeGlobalState();
  const stateNotesObj = asObject(extractKey(stateObj, "notes"));
  if (stateNotesObj) {
    const nodesArr = asArray(extractKey(stateNotesObj, "nodes"));
    let editedAtNeedsBackfill = false;
    if (nodesArr) {
      state2.notes.nodes = nodesArr.map((nodeArrVal) => {
        const nodeObj = mustGetDefined(asObject(nodeArrVal) || asNull(nodeArrVal));
        if (nodeObj === null) return null;
        const noteObjDataObj = mustGetDefined(asObject(extractKey(nodeObj, "data")));
        const noteData = defaultNote();
        const editedAt = asDate(extractKey(noteObjDataObj, "editedAt"));
        if (editedAt) {
          noteData.editedAt = editedAt;
        } else {
          editedAtNeedsBackfill = true;
        }
        deserializeObject(noteData, noteObjDataObj, "note.nodes[].data");
        const node = newTreeNode(noteData);
        node.childIds = mustGetDefined(asNoteIds(extractKey(nodeObj, "childIds")));
        deserializeObject(node, nodeObj, "note.nodes[]");
        return node;
      });
    }
    deserializeObject(state2.notes, stateNotesObj, "notes");
    if (editedAtNeedsBackfill) {
      for (const note of state2.notes.nodes) {
        if (!note) continue;
        if (note.childIds.length > 0) continue;
        let current = note;
        const editedAt = note.data.openedAt;
        while (!idIsNilOrRoot(current.id)) {
          current.data.editedAt = new Date(editedAt);
          current = getNote(state2.notes, current.parentId);
        }
      }
    }
  }
  const activitiesArr = mustGetDefined(asArray(extractKey(stateObj, "activities")));
  state2.activities = activitiesArr.map((val2, i) => {
    const activityObj = mustGetDefined(asObject(val2));
    const t = mustGetDefined(asDate(extractKey(activityObj, "t")));
    const activity = defaultActivity(t);
    activity.nId = asNumber(extractKey(activityObj, "nId"));
    activity.breakInfo = asString(extractKey(activityObj, "breakInfo"));
    activity.locked = asTrue(extractKey(activityObj, "locked"));
    activity.deleted = asTrue(extractKey(activityObj, "deleted"));
    activity.c = asNumber(extractKey(activityObj, "c"));
    deserializeObject(activity, activityObj);
    return activity;
  });
  filterInPlace(state2.activities, (a) => a.breakInfo != null || a.nId != null);
  filterInPlace(state2.activities, (a, i) => {
    const isSorted = i === state2.activities.length - 1 || state2.activities[i].t.getTime() < state2.activities[i + 1].t.getTime();
    return isSorted;
  });
  state2.activities.forEach((a, i) => {
    const isSorted = i === 0 || state2.activities[i - 1].t.getTime() < state2.activities[i].t.getTime();
    if (!isSorted) {
      throw new Error("BRUH " + i);
    }
  });
  const taskStreamsArr = asArray(extractKey(stateObj, "taskStreams"));
  if (taskStreamsArr) {
    state2.taskStreams = taskStreamsArr.map((taskStreamVal) => {
      const taskStreamObj = mustGetDefined(asObject(taskStreamVal));
      const name = mustGetDefined(asString(extractKey(taskStreamObj, "name")));
      const taskStream = newTaskStream(name);
      taskStream.noteIds = mustGetDefined(asNoteIds(extractKey(taskStreamObj, "noteIds")));
      deserializeObject(taskStream, taskStreamObj);
      return taskStream;
    });
  }
  const scheduledNoteIds = asNoteIds(extractKey(stateObj, "scheduledNoteIds"));
  if (scheduledNoteIds) state2.scheduledNoteIds = scheduledNoteIds;
  const workdayConfigObj = asObject(extractKey(stateObj, "workdayConfig"));
  if (workdayConfigObj) {
    const weekdayConfigsArr = mustGetDefined(asArray(extractKey(workdayConfigObj, "weekdayConfigs")));
    state2.workdayConfig.weekdayConfigs = weekdayConfigsArr.map((u) => {
      const weekdayConfigObj = mustGetDefined(asObject(u));
      const weekdayConfig = newWorkdayConfigWeekDay();
      const weekdays = mustGetDefined(asArray(extractKey(weekdayConfigObj, "weekdayFlags")));
      for (let i = 0; i < weekdayConfig.weekdayFlags.length && i < weekdays.length; i++) {
        weekdayConfig.weekdayFlags[i] = !!weekdays[i];
      }
      deserializeObject(weekdayConfig, weekdayConfigObj);
      return weekdayConfig;
    });
    const holidayConfigsArr = mustGetDefined(asArray(extractKey(workdayConfigObj, "holidays")));
    state2.workdayConfig.holidays = holidayConfigsArr.map((u) => {
      const holidayConfigObj = mustGetDefined(asObject(u));
      const holidayConfig = {
        name: "",
        date: /* @__PURE__ */ new Date()
      };
      deserializeObject(holidayConfig, holidayConfigObj);
      return holidayConfig;
    });
    deserializeObject(state2.workdayConfig, workdayConfigObj);
  }
  const mainGraphDataObj = asObject(extractKey(stateObj, "mainGraphData"));
  if (mainGraphDataObj) {
    state2.mainGraphData.nodes = mustGetDefined(asStringMap(extractKey(mainGraphDataObj, "nodes"), (u) => {
      const nodeObj = mustGetDefined(asObject(u));
      const node = newGraphNode("", "", 0, 0);
      deserializeObject(node, nodeObj);
      return node;
    }));
    state2.mainGraphData.edges = mustGetDefined(asStringMap(extractKey(mainGraphDataObj, "edges"), (u) => {
      const edgeObj = mustGetDefined(asObject(u));
      const edge = newGraphEdge("", "", 0);
      deserializeObject(edge, edgeObj);
      return edge;
    }));
    deserializeObject(state2.mainGraphData, mainGraphDataObj);
  }
  deserializeObject(state2, stateObj);
  return state2;
}
const nonLatinCharRegex = /[^\u0000-\u00ff]/;
function containsNonLatinCodepoints(s) {
  return nonLatinCharRegex.test(s);
}
function fuzzyFind(text, query, {
  // NOTE: you probably never want to set this to anything higher than 1
  allowableMistakes = 1,
  mistakePenalty = 5,
  prefixBuff = 1,
  limit = 20
}) {
  const result = { ranges: [], score: 0 };
  query = query.toLowerCase();
  text = text.toLowerCase();
  if (query.length === 0) {
    return result;
  }
  if (query.length <= 2) {
    if (containsNonLatinCodepoints(query)) {
      allowableMistakes = 0;
    }
    if (query.length === 1) {
      return result;
    }
  }
  for (let i = 0; i + query.length - 1 < text.length; i++) {
    let mistakesRemaining = Math.max(0, Math.min(query.length - allowableMistakes, allowableMistakes));
    let mistakesFound = 0;
    let isMatch = true;
    let iTempOffset = 0;
    for (let j = 0; j < query.length; j++) {
      if (text[i + iTempOffset + j] !== query[j]) {
        if (j > 0) {
          if (text[i + iTempOffset + j] === query[j + 1]) {
            j++;
          } else if (text[i + iTempOffset + j + 1] === query[j]) {
            iTempOffset++;
          }
        }
        mistakesRemaining--;
        mistakesFound++;
      }
      if (mistakesRemaining < 0) {
        isMatch = false;
        break;
      }
    }
    if (!isMatch) {
      continue;
    }
    result.ranges.push([i, i + query.length]);
    let thisMatchScore = 0;
    thisMatchScore += 1 / (1 + mistakePenalty * mistakesFound);
    if (mistakesFound === 0 && prefixBuff) {
      if (i === 0 || // NOTE: could be unicode-related bugs with this one. We don't care for now
      text[i - 1].trim() === "") {
        thisMatchScore += prefixBuff;
      }
      result.score += thisMatchScore;
    }
    if (result.ranges.length >= limit) {
      break;
    }
    i += query.length - 1;
  }
  return result;
}
const VERSION_NUMBER = "2.00.00";
const VERSION_NUMBER_MONOTONIC = 219;
function setTheme(newTheme) {
  state.currentTheme = newTheme;
  if (newTheme === "Light") {
    setAppTheme(lightTheme);
  } else {
    setAppTheme(darkTheme);
  }
}
function notesMutated(state2) {
  state2._notesMutationCounter++;
}
function newTaskStream(name) {
  return { name, noteIds: [], _idx: 0 };
}
function newAppSettings() {
  return {
    nonEditingNotesOnOneLine: true,
    parentNotesOnOneLine: true,
    spacesInsteadOfTabs: true,
    tabStopSize: 4
  };
}
const doneSuffixes = ["DONE", "MERGED", "DECLINED"];
function getDoneNotePrefixOrSuffix(note) {
  for (let i = 0; i < doneSuffixes.length; i++) {
    const suffix = doneSuffixes[i];
    if (note.text.trimEnd().endsWith(suffix) || note.text.trimStart().startsWith(suffix)) {
      return suffix;
    }
  }
  return void 0;
}
function isNoteShelved(note) {
  return note.text.trimEnd().endsWith("SHELVED") || note.text.trimStart().startsWith("SHELVED");
}
function getNoteTextWithoutPriority(note) {
  const priority = getTodoNotePriority(note);
  let idx = priority;
  const shelved = isNoteRequestingShelf(note);
  if (shelved) {
    idx += 2;
  }
  return (shelved ? "[Shelved] " : "") + note.text.substring(idx).trim();
}
function isHigherLevelTask(note) {
  return getTodoNotePriority(note.data) >= 2;
}
function isNoteRequestingShelf(note) {
  return note.text.startsWith("||");
}
function getTodoNotePriority(note) {
  let priority = 0;
  let text = note.text;
  let pos = 0;
  if (isNoteRequestingShelf(note)) {
    pos += 2;
  }
  if (text[pos] === " ") {
    pos++;
  }
  for (let i = pos; i < text.length; i++) {
    if (text[i] !== ">") {
      break;
    }
    priority++;
  }
  return priority;
}
const STATUS_NOT_COMPUTED = 0;
const STATUS_IN_PROGRESS = 1;
const STATUS_ASSUMED_DONE = 2;
const STATUS_DONE = 3;
const STATUS_SHELVED = 4;
function noteStatusToString(noteStatus) {
  switch (noteStatus) {
    case STATUS_IN_PROGRESS:
      return "[ ]";
    case STATUS_ASSUMED_DONE:
      return "[*]";
    case STATUS_DONE:
      return "[x]";
    case STATUS_SHELVED:
      return "[-]";
  }
  return "??";
}
function newNoteTreeGlobalState() {
  const rootNote = defaultNote();
  rootNote.text = "This root node should not be visible. If it is, you've encountered a bug!";
  const notes = newTreeStore(rootNote);
  const state2 = {
    // Only increment this for massive changes! Otherwise, try to keep migrations bacwards compatible
    schemaMajorVersion: 2,
    notes,
    _notesMutationCounter: 0,
    currentNoteId: NIL_ID,
    dockedMenu: "activities",
    showDockedMenu: false,
    activities: [],
    _activitiesMutationCounter: 0,
    _scratchPadCanvasLayers: [],
    _scratchPadCanvasCurrentNoteIdPendingSave: NIL_ID,
    mainGraphData: newGraphData(),
    settings: newAppSettings(),
    _showAllNotes: false,
    currentTheme: "Light",
    breakAutoInsertLastPolledTime: "",
    criticalSavingError: "",
    taskStreams: [],
    scheduledNoteIds: [],
    currentTaskStreamIdx: 0,
    textOnArrival: "",
    textOnArrivalNoteId: NIL_ID,
    workdayConfig: {
      weekdayConfigs: [newWorkdayConfigWeekDay(9, 7.5)],
      holidays: []
    },
    _flatNoteIds: [],
    // used by the note tree view, can include collapsed subsections
    _isEditingFocusedNote: false,
    // global flag to control if we're editing a note
    // don't set this if our tree is corrupted!
    _criticalLoadingError: "",
    _criticalLoadingErrorWasOurFault: false,
    _currentlyViewingActivityIdx: 0,
    _currentActivityScopedNoteId: NIL_ID,
    _isShowingDurations: false,
    _activitiesFrom: null,
    _activitiesFromIdx: -1,
    _activitiesTo: null,
    _activitiesToIdx: -1,
    _activityIndices: [],
    _useActivityIndices: false,
    _lastNoteId: void 0,
    _currentDateScope: "week",
    _currentDateScopeWeekDay: -1,
    _currentFlatNotesRootId: NIL_ID,
    _currentFlatNotesRootHltId: NIL_ID,
    _currentModal: 0,
    _showStatusText: false,
    _statusText: "",
    _statusTextColor: ""
  };
  setActivityRangeToToday(state2);
  return state2;
}
function loadStateFromJSON(savedStateJSON) {
  if (!savedStateJSON) {
    return { error: "JSON was empty" };
  }
  try {
    let jsonObj = JSON.parse(savedStateJSON);
    const loadedState = asNoteTreeGlobalState(jsonObj);
    return { state: loadedState };
  } catch (err) {
    return { criticalError: err.message };
  }
}
function setStateFromJSON(savedStateJSON, then) {
  if (typeof savedStateJSON !== "string") {
    logTrace("Got a blob, converting to string before using...");
    savedStateJSON.text().then((text) => setStateFromJSON(text, then)).catch((err) => console.error("Error with parsing json blob: ", err));
    return;
  }
  logTrace("Setting state from JSON string");
  state._criticalLoadingError = "";
  const loaded = loadStateFromJSON(savedStateJSON);
  if (loaded.criticalError) {
    console.error(loaded.criticalError);
    logTrace("Loading a new state would be a mistake right about now");
    state._criticalLoadingError = loaded.criticalError;
    state._criticalLoadingErrorWasOurFault = true;
  } else if (loaded.error) {
    logTrace("Couldn't load state - " + loaded.error);
    setState(newNoteTreeGlobalState());
  } else if (loaded.state) {
    setState(loaded.state);
  }
  then == null ? void 0 : then(loaded.criticalError || loaded.error || "Unknown error occured");
}
function setState(newState) {
  state = newState;
}
function getLastActivity(state2) {
  return state2.activities[state2.activities.length - 1];
}
function defaultNote() {
  return {
    // the following is valuable user data
    id: NIL_ID,
    text: "",
    openedAt: /* @__PURE__ */ new Date(),
    editedAt: /* @__PURE__ */ new Date(),
    lastSelectedChildIdx: 0,
    // the following are just visual flags which are frequently recomputed
    _higherLevelTask: void 0,
    _status: STATUS_NOT_COMPUTED,
    _shelved: false,
    _everyChildNoteDone: false,
    _isAboveCurrentNote: false,
    _isUnderCurrent: false,
    _depth: 0,
    _durationUnranged: 0,
    _durationRanged: 0,
    _activityListMostRecentIdx: 0,
    _taskStreams: [],
    _isScheduled: false
  };
}
function getActivityTime(activity) {
  if (!activity) {
    return /* @__PURE__ */ new Date();
  }
  return activity.t;
}
function setNoteText(state2, note, text) {
  note.data.text = text;
  recomputeNoteStatusRecursively(state2, note);
  notesMutated(state2);
  let current = note;
  const now = /* @__PURE__ */ new Date();
  while (!idIsNilOrRoot(current.id)) {
    current.data.editedAt = new Date(now);
    current = getNote(state2.notes, current.parentId);
  }
}
function recomputeNoteStatusRecursively(state2, note, recomputeParents = true, recomputeChildren = true) {
  if (note.childIds.length === 0) {
    recomputeParents = true;
  } else if (note.childIds.length > 0) {
    let status = STATUS_IN_PROGRESS;
    {
      const lastId = note.childIds[note.childIds.length - 1];
      const lastNote = getNote(state2.notes, lastId);
      if (getDoneNotePrefixOrSuffix(lastNote.data)) {
        status = STATUS_DONE;
      } else if (isNoteShelved(lastNote.data)) {
        status = STATUS_SHELVED;
      }
    }
    let foundDoneNoteUnderThisParent = false;
    let foundShelvedNoteUnderThisParent = false;
    for (let i = note.childIds.length - 1; i >= 0; i--) {
      const id = note.childIds[i];
      const child = getNote(state2.notes, id);
      if (child.childIds.length > 0) {
        if (foundShelvedNoteUnderThisParent) {
          shelveNotesRecursively(state2, child);
        } else if (child.data._status === STATUS_NOT_COMPUTED) {
          recomputeNoteStatusRecursively(state2, child, false, true);
          assert(child.data._status !== STATUS_NOT_COMPUTED);
        }
      } else {
        if (getDoneNotePrefixOrSuffix(child.data) || foundDoneNoteUnderThisParent) {
          child.data._status = STATUS_DONE;
          foundDoneNoteUnderThisParent = true;
        } else if (isNoteShelved(child.data) || foundShelvedNoteUnderThisParent) {
          foundShelvedNoteUnderThisParent = true;
          recomputeChildren = false;
          child.data._status = STATUS_SHELVED;
        } else if (i === note.childIds.length - 1) {
          child.data._status = STATUS_IN_PROGRESS;
        } else {
          if (getTodoNotePriority(child.data) === 0) {
            child.data._status = STATUS_ASSUMED_DONE;
          } else {
            child.data._status = STATUS_IN_PROGRESS;
          }
        }
      }
      if (child.data._status !== STATUS_DONE && child.data._status !== STATUS_SHELVED) {
        status = STATUS_IN_PROGRESS;
      }
    }
    const previousStatus = note.data._status;
    const noteStatusChanged = previousStatus !== status;
    if (noteStatusChanged) {
      note.data._status = status;
      if (previousStatus !== STATUS_NOT_COMPUTED) {
        recomputeParents = true;
      }
      if (previousStatus === STATUS_SHELVED) {
        clearNoteStatusRecursively(state2, note);
        recomputeNoteStatusRecursively(state2, note, false, true);
      }
    }
  }
  if (recomputeParents) {
    if (!idIsNil(note.parentId)) {
      const parent = getNote(state2.notes, note.parentId);
      recomputeNoteStatusRecursively(state2, parent, true, false);
    }
  }
}
function shelveNotesRecursively(state2, note) {
  note.data._status = STATUS_SHELVED;
  for (let i = 0; i < note.childIds.length; i++) {
    const child = getNote(state2.notes, note.childIds[i]);
    shelveNotesRecursively(state2, child);
  }
}
function clearNoteStatusRecursively(state2, note) {
  note.data._status = STATUS_NOT_COMPUTED;
  for (let i = 0; i < note.childIds.length; i++) {
    const child = getNote(state2.notes, note.childIds[i]);
    clearNoteStatusRecursively(state2, child);
  }
}
function recomputeAllNoteDurations(state2, activitiesFrom, activitiesTo) {
  state2._activitiesToIdx = -1;
  state2._activitiesFromIdx = -1;
  forEachNode(state2.notes, (note) => {
    note.data._durationUnranged = 0;
    note.data._durationUnrangedOpenSince = void 0;
    note.data._durationRanged = 0;
    note.data._durationRangedOpenSince = void 0;
  });
  const activities = state2.activities;
  for (let i = 0; i < activities.length; i++) {
    const a0 = activities[i];
    const note = getNoteOrUndefined(state2.notes, a0.nId);
    if (!note) {
      continue;
    }
    const a1 = activities[i + 1];
    const duration = getActivityDurationMs(a0, a1);
    const isCurrentActivity = !a1;
    {
      let parentNote = note;
      while (!idIsNil(parentNote.parentId)) {
        if (!isCurrentActivity) {
          parentNote.data._durationUnranged += duration;
        } else {
          parentNote.data._durationUnrangedOpenSince = getActivityTime(a0);
        }
        parentNote = getNote(state2.notes, parentNote.parentId);
      }
    }
    if ((!activitiesFrom || activitiesFrom <= getActivityTime(a0)) && (!activitiesTo || getActivityTime(a1) <= activitiesTo)) {
      if (state2._activitiesFromIdx === -1) {
        state2._activitiesFromIdx = i;
      }
      state2._activitiesToIdx = i;
      {
        let parentNote = note;
        while (!idIsNil(parentNote.parentId)) {
          if (!isCurrentActivity) {
            parentNote.data._durationRanged += duration;
          } else {
            parentNote.data._durationRangedOpenSince = getActivityTime(a0);
          }
          parentNote = getNote(state2.notes, parentNote.parentId);
        }
      }
    }
  }
}
function parentNoteContains(state2, parentId, note) {
  while (!idIsNil(note.parentId)) {
    if (note.id === parentId) {
      return true;
    }
    note = getNote(state2.notes, note.parentId);
  }
  return false;
}
const NOT_COLLAPSED = 0;
const COLLAPSED_HLT = 1;
const COLLAPSED_ROOT = 2;
const COLLAPSED_STATUS = 3;
function isNoteCollapsed(note) {
  if (isHigherLevelTask(note)) return COLLAPSED_HLT;
  if (idIsNilOrRoot(note.id)) return COLLAPSED_ROOT;
  if (note.data._status !== STATUS_IN_PROGRESS) return COLLAPSED_STATUS;
  return NOT_COLLAPSED;
}
function getActivityTextOrUndefined(state2, activity) {
  if (activity.nId === 0) {
    return "< deleted root note >";
  }
  if (activity.nId) {
    const text = getNote(state2.notes, activity.nId).data.text;
    if (activity.deleted) {
      return "< used to be under > " + text;
    }
    return text;
  }
  if (activity.breakInfo) {
    return activity.breakInfo;
  }
  return void 0;
}
function getActivityText(state2, activity) {
  return getActivityTextOrUndefined(state2, activity) || "< unknown activity text! >";
}
function getActivityDurationMs(activity, nextActivity) {
  const startTimeMs = getActivityTime(activity).getTime();
  const nextStart = (nextActivity ? getActivityTime(nextActivity) : /* @__PURE__ */ new Date()).getTime();
  return nextStart - startTimeMs;
}
function createNewNote(state2, text) {
  const note = defaultNote();
  note.text = text;
  const newTreeNode$1 = newTreeNode(note);
  addAsRoot(state2.notes, newTreeNode$1);
  note.id = newTreeNode$1.id;
  pushNoteActivity(state2, newTreeNode$1.id, true);
  return newTreeNode$1;
}
function activityNoteIdMatchesLastActivity(state2, activity) {
  const lastActivity = getLastActivity(state2);
  if (!lastActivity) {
    return false;
  }
  if (isBreak(lastActivity)) {
    return lastActivity.breakInfo === activity.breakInfo;
  }
  return lastActivity.nId === activity.nId;
}
function canActivityBeReplacedWithNewActivity(state2, lastActivity) {
  const ONE_SECOND2 = 1e3;
  const activityDurationMs = getActivityDurationMs(lastActivity, void 0);
  if (lastActivity && lastActivity.nId && lastActivity.c === 1 && !lastActivity.deleted) {
    return false;
  }
  if (
    // A bunch of conditions that make this activity something we don't need to keep around as much
    !lastActivity || !lastActivity.nId || !hasNote(state2.notes, lastActivity.nId) || lastActivity.deleted || lastActivity.c !== 1 || // activity wasn't created, but edited
    isBreak(lastActivity) || !getNote(state2.notes, lastActivity.nId).data.text.trim()
  ) {
    const LONG_DEBOUNCE = 1 * 60 * ONE_SECOND2;
    return activityDurationMs < LONG_DEBOUNCE;
  }
  const SHORT_DEBOUNCE = 2 * ONE_SECOND2;
  return activityDurationMs < SHORT_DEBOUNCE;
}
function pushActivity(state2, activity) {
  const lastActivity = getLastActivity(state2);
  if (activityNoteIdMatchesLastActivity(state2, activity)) {
    return;
  }
  if (lastActivity && canActivityBeReplacedWithNewActivity(state2, lastActivity)) {
    state2.activities.pop();
    if (activityNoteIdMatchesLastActivity(state2, activity)) {
      return;
    }
  }
  state2.activities.push(activity);
  state2._activitiesMutationCounter++;
}
function isNoteEmpty(note) {
  return note.data.text.length === 0;
}
function deleteNoteIfEmpty(state2, note) {
  if (!isNoteEmpty(note)) {
    return false;
  }
  if (note.childIds.length > 0) {
    if (state2.textOnArrivalNoteId === note.id && state2.textOnArrival) {
      note.data.text = state2.textOnArrival;
      state2.textOnArrival = "";
      state2.textOnArrivalNoteId = NIL_ID;
    } else {
      note.data.text = "Some note we cant delete because of the x" + note.childIds.length + " notes under it :(";
    }
    state2._showStatusText = true;
    state2._statusText = "Can't delete notes with children!";
    state2._statusTextColor = "#F00";
    notesMutated(state2);
    return true;
  }
  if (idIsNil(note.parentId)) {
    return false;
  }
  if (getSizeExcludingRoot(state2.notes) <= 1) {
    return false;
  }
  const nId = note.id;
  const parentId = note.parentId;
  remove(state2.notes, note);
  for (let i = 0; i < state2.activities.length; i++) {
    const activity = state2.activities[i];
    if (activity.nId === nId) {
      activity.nId = parentId;
      activity.deleted = true;
    }
  }
  while (state2.activities.length > 0 && state2.activities[state2.activities.length - 1].deleted) {
    state2.activities.pop();
  }
  for (const stream of state2.taskStreams) {
    removeNoteFromNoteIds(stream.noteIds, note.id);
  }
  removeNoteFromNoteIds(state2.scheduledNoteIds, note.id);
  notesMutated(state2);
  return true;
}
function hasNote(tree, id) {
  return hasNode(tree, id);
}
function getNote(tree, id) {
  return getNode(tree, id);
}
function idIsNilOrUndefined(id) {
  return id === -1 || id === null || id === void 0;
}
function idIsNil(id) {
  return id === NIL_ID;
}
function idIsNilOrRoot(id) {
  return id === NIL_ID || id === ROOT_ID;
}
function idIsRoot(id) {
  return id === ROOT_ID;
}
function getNoteOrUndefined(tree, id) {
  if (!idIsNilOrUndefined(id) && hasNote(tree, id)) {
    return getNote(tree, id);
  }
  return void 0;
}
function getCurrentNote(state2) {
  if (!hasNote(state2.notes, state2.currentNoteId)) {
    const rootChildIds = getRootNote(state2).childIds;
    if (rootChildIds.length === 0) {
      const newNote = createNewNote(state2, "First Note");
      addUnder(state2.notes, getRootNote(state2), newNote);
    }
    state2.currentNoteId = rootChildIds[rootChildIds.length - 1];
  }
  return getNote(state2.notes, state2.currentNoteId);
}
function pushNoteActivity(state2, noteId, isNewNote) {
  const activity = defaultActivity(/* @__PURE__ */ new Date());
  activity.nId = noteId;
  activity.c = isNewNote ? 1 : void 0;
  pushActivity(state2, activity);
}
function defaultActivity(t) {
  return {
    // at least one of these must be defined:
    t,
    nId: void 0,
    breakInfo: void 0,
    c: void 0,
    locked: void 0,
    deleted: void 0
  };
}
function newBreakActivity(breakInfoText, time, locked) {
  const activity = defaultActivity(time);
  activity.breakInfo = breakInfoText;
  activity.locked = locked || void 0;
  return activity;
}
const DONT_INTERRUPT = 1;
function pushBreakActivity(state2, breakActivtiy, flags = 0) {
  if (breakActivtiy.nId || !breakActivtiy.breakInfo) {
    throw new Error("Invalid break activity");
  }
  pushActivity(state2, breakActivtiy);
  if (!(flags & DONT_INTERRUPT)) {
    if (state2._isEditingFocusedNote) {
      setIsEditingCurrentNote(state2, false);
    }
  }
}
function isCurrentlyTakingABreak(state2) {
  const last = getLastActivity(state2);
  return !!last && isBreak(last);
}
function forEachParentNote(tree, start, it) {
  let current = start;
  while (!idIsNilOrRoot(current.id)) {
    it(current);
    current = getNote(tree, current.parentId);
  }
}
function forEachChildNote(state2, note, it) {
  for (let i = 0; i < note.childIds.length; i++) {
    const id = note.childIds[i];
    const child = getNote(state2.notes, id);
    it(child);
  }
}
function setCurrentNote(state2, noteId, noteIdJumpedFrom) {
  if (!noteId) {
    return;
  }
  const note = getNoteOrUndefined(state2.notes, noteId);
  if (!note || note === getRootNote(state2)) {
    return false;
  }
  const currentNoteBeforeMove = getCurrentNote(state2);
  if (currentNoteBeforeMove.id === note.id) {
    return;
  }
  if (!hasNode(state2.notes, note.id)) {
    return;
  }
  setNoteAsLastSelected(state2, note);
  state2._lastNoteId = noteIdJumpedFrom;
  state2.currentNoteId = note.id;
  setIsEditingCurrentNote(state2, false);
  deleteNoteIfEmpty(state2, currentNoteBeforeMove);
  setCurrentActivityIdxToCurrentNote(state2);
  return true;
}
function setCurrentActivityIdxToCurrentNote(state2) {
  const note = getCurrentNote(state2);
  const idx = getMostRecentActivityIdx(state2, note);
  if (idx !== -1) {
    state2._currentlyViewingActivityIdx = idx;
  }
}
function setNoteAsLastSelected(state2, note) {
  if (idIsNil(note.parentId)) {
    return;
  }
  const parent = getNote(state2.notes, note.parentId);
  parent.data.lastSelectedChildIdx = parent.childIds.indexOf(note.id);
}
function setIsEditingCurrentNote(state2, isEditing) {
  state2._isEditingFocusedNote = isEditing;
  if (isEditing) {
    const currentNote = getCurrentNote(state2);
    pushNoteActivity(state2, currentNote.id, false);
    setCurrentActivityIdxToCurrentNote(state2);
    setNoteAsLastSelected(state2, currentNote);
    state2.textOnArrival = currentNote.data.text;
    state2.textOnArrivalNoteId = currentNote.id;
  } else {
    if (!isCurrentlyTakingABreak(state2)) {
      pushBreakActivity(state2, newBreakActivity("Planning/organising tasks", /* @__PURE__ */ new Date(), false));
    }
  }
}
function dfsPre(state2, note, fn) {
  fn(note);
  for (const id of note.childIds) {
    const note2 = getNote(state2.notes, id);
    dfsPre(state2, note2, fn);
  }
}
function getRootNote(state2) {
  return getNote(state2.notes, ROOT_ID);
}
function isBreak(activity) {
  return activity.breakInfo !== void 0;
}
function getMostRecentActivityIdx(state2, note) {
  for (let i = state2.activities.length - 1; i > 0; i--) {
    if (state2.activities[i].nId === note.id) {
      return i;
    }
  }
  return -1;
}
function setActivityRangeToToday(state2) {
  const dateFrom = /* @__PURE__ */ new Date();
  const dateTo = /* @__PURE__ */ new Date();
  addDays(dateTo, 1);
  floorDateLocalTime(dateFrom);
  floorDateLocalTime(dateTo);
  state2._currentDateScope = "any";
  state2._activitiesFrom = dateFrom;
  state2._activitiesTo = dateTo;
}
function setActivityRangeToThisWeek(state2) {
  const dateFrom = /* @__PURE__ */ new Date();
  floorDateToWeekLocalTime(dateFrom);
  const dateTo = new Date(dateFrom.getTime());
  addDays(dateTo, 7);
  state2._activitiesFrom = dateFrom;
  state2._activitiesTo = dateTo;
}
function resetState() {
  state = newNoteTreeGlobalState();
}
let state = newNoteTreeGlobalState();
const PROJECT_NAME = "note-tree";
const LAST_SAVED_TIMESTAMP_KEY = PROJECT_NAME + "-lastSavedTimestamp";
const LAST_SAVED_VERSION_KEY = PROJECT_NAME + "-lastSavedVersion";
let lastLoadedTime = "";
let loading = false;
let db;
function loadState(then) {
  const lastSavedVersion = localStorage.getItem(LAST_SAVED_VERSION_KEY);
  if (lastSavedVersion) {
    const versionInt = parseInt(lastSavedVersion);
    if (versionInt !== null) {
      if (versionInt > VERSION_NUMBER_MONOTONIC) {
        const message = "Your state has been saved using a newer version of the app. You shold close this older version and open that one in order to avoid data loss. Saving has been disabled for this session.";
        logTrace(message);
        state._criticalLoadingError = message;
        state._criticalLoadingErrorWasOurFault = false;
        then("OLD_VERSION");
        return;
      }
    }
  }
  if (loading) {
    logTrace("Already loading!");
    return;
  }
  if (lastLoadedTime === getLastSavedTimestampLocalstate()) {
    logTrace("We're already at the latest version, no need to reload");
    return;
  }
  loading = true;
  const thenInternal = (error) => {
    loading = false;
    lastLoadedTime = getLastSavedTimestampLocalstate();
    then(error);
  };
  logTrace("Opening DB...");
  const request = window.indexedDB.open(INDEXED_DB_KV_STORE_NAME, 1);
  request.onerror = (e) => {
    loadStateFromLocalStorage();
    console.error("Error requesting db - ", e, request.error);
    loading = false;
  };
  request.onupgradeneeded = () => {
    logTrace("Migrating DB...");
    db = request.result;
    const kvStore = db.createObjectStore(INDEXED_DB_KV_STORE_NAME, { keyPath: "key" });
    kvStore.createIndex("value", "value", { unique: false });
  };
  request.onsuccess = () => {
    db = request.result;
    logTrace("Opened DB");
    if (!db) throw new Error("DB should be defined here");
    const kvStore = db.transaction([INDEXED_DB_KV_STORE_NAME], "readonly").objectStore(INDEXED_DB_KV_STORE_NAME);
    const txRequest = kvStore.get(KV_STORE_STATE_KEY);
    txRequest.onerror = (e) => {
      console.error("Error getting kv store - ", e, request.error);
      loading = false;
    };
    txRequest.onsuccess = () => {
      logTrace("Checking IndexedDB...");
      const savedStateJSONWrapper = txRequest.result;
      if (!savedStateJSONWrapper) {
        logTrace("We don't have anything saved yet. We might have something in local storage though. If not, we'll just start with fresh state");
        loadStateFromLocalStorage();
        thenInternal("");
        return;
      }
      logTrace("Loaded data from IndexedDB (and not localStorage)");
      setStateFromJSON(savedStateJSONWrapper.value, thenInternal);
    };
  };
}
function getLastSavedTimestampLocalstate() {
  return localStorage.getItem(LAST_SAVED_TIMESTAMP_KEY) || "";
}
function saveState(state2, then) {
  if (state2._criticalLoadingError) {
    logTrace("State shouldn't be saved right now - most likely we'll irrecoverably corrupt it");
    then("");
    return;
  }
  if (!db) {
    console.error("Tried to save the state before we even have our database!!!");
    return;
  }
  const serialized = serializeToJSON(state2);
  const serializedBlob = new Blob([serialized], { type: "text/plain" });
  const kvStoreTx = db.transaction([INDEXED_DB_KV_STORE_NAME], "readwrite");
  kvStoreTx.objectStore(INDEXED_DB_KV_STORE_NAME).put({
    key: KV_STORE_STATE_KEY,
    value: serializedBlob
  });
  kvStoreTx.oncomplete = () => {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const version = VERSION_NUMBER_MONOTONIC;
    localStorage.setItem(LAST_SAVED_TIMESTAMP_KEY, timestamp);
    localStorage.setItem(LAST_SAVED_VERSION_KEY, version.toString());
    lastLoadedTime = timestamp;
    logTrace("Saved! (as a blob this time, and not text!)");
    then(serialized);
  };
  kvStoreTx.onerror = (event) => {
    console.error("An error occured while trying to save as a blob: ", event, kvStoreTx.error);
  };
}
function loadStateFromLocalStorage() {
  const savedStateJSON = localStorage.getItem(LOCAL_STORAGE_KEY_LEGACY);
  if (savedStateJSON) {
    logTrace("Loaded legacy data from local storage");
    setStateFromJSON(savedStateJSON);
    return true;
  }
  logTrace("No saved data was found");
  return false;
}
function getHigherLevelTask(state2, note) {
  let result = void 0;
  while (!idIsNil(note.parentId)) {
    if (isHigherLevelTask(note)) {
      result = note;
      break;
    }
    note = getNote(state2.notes, note.parentId);
  }
  return result;
}
function getNumSiblings(state2, note) {
  if (idIsNil(note.parentId)) return 0;
  const parent = getNote(state2.notes, note.parentId);
  return parent.childIds.length;
}
function removeNoteFromNoteIds(noteIds, id) {
  filterInPlace(noteIds, (nId) => nId !== id);
}
function applyPendingScratchpadWrites(state2) {
  if (state2._scratchPadCanvasLayers.length === 0) {
    return;
  }
  const scratchpadNote = getNoteOrUndefined(state2.notes, state2._scratchPadCanvasCurrentNoteIdPendingSave);
  if (!scratchpadNote) {
    return;
  }
  const text = getLayersString(state2._scratchPadCanvasLayers);
  scratchpadNote.data.text = text;
  state2._scratchPadCanvasCurrentNoteIdPendingSave = NIL_ID;
}
function newWorkdayConfigWeekDay(dayStartHour = 0, workingHours = 0) {
  return {
    dayStartHour,
    workingHours,
    weekdayFlags: [false, false, false, false, false, false, false]
  };
}
const LOCAL_STORAGE_KEY_LEGACY = "NoteTree.Everything";
const INDEXED_DB_KV_STORE_NAME = "NoteTreeKVStore";
const KV_STORE_STATE_KEY = "State";
function getCurrentStateAsJSON() {
  return serializeToJSON(state);
}
function getNumDays(s) {
  let numDays;
  if (s.scope === "week") {
    numDays = 7;
  } else {
    numDays = 1;
  }
  return numDays;
}
function newDurationsViewState() {
  return {
    scrollContainer: newScrollContainer(),
    tableRowPos: newListPosition(),
    tableColPos: newListPosition(),
    durations: [],
    activitiesFrom: null,
    activitiesTo: null,
    hideBreaks: false,
    scope: "week",
    activityFilter: null
  };
}
function handleKeyboardInput$5(ctx, s) {
  const vNav = getNavigableListInput(ctx, s.tableRowPos.idx, -1, s.durations.length);
  if (vNav) {
    setTableRow(ctx, s, vNav.newIdx);
  }
  const numDays = getNumDays(s);
  const hNav = getNavigableListInput(ctx, s.tableColPos.idx, -1, numDays + 1, AXIS_HORIZONTAL);
  if (hNav) {
    setTableCol(ctx, s, hNav.newIdx);
  }
}
function setTableRow(ctx, s, newRow) {
  s.tableRowPos.idx = clampedListIdxRange(newRow, -1, s.durations.length);
  startScrolling(s.scrollContainer, true);
  setTableCol(ctx, s, s.tableColPos.idx);
}
function setTableCol(ctx, s, newCol) {
  if (!s.activitiesTo || !s.activitiesFrom) {
    return;
  }
  const numDays = getNumDays(s);
  s.tableColPos.idx = clampedListIdxRange(newCol, -1, numDays + 1);
  let fullRecomputation = false;
  if (s.tableColPos.idx === -1) {
    addDays(s.activitiesFrom, -1);
    floorDateToWeekLocalTime(s.activitiesFrom);
    s.activitiesTo = new Date(s.activitiesFrom);
    addDays(s.activitiesTo, 7);
    s.tableColPos.idx = numDays - 1;
    fullRecomputation = true;
  } else if (s.tableColPos.idx === numDays) {
    const newActivitiesFrom = new Date(s.activitiesFrom);
    addDays(newActivitiesFrom, 7);
    if (newActivitiesFrom.getTime() < ctx.now.getTime()) {
      s.activitiesFrom = newActivitiesFrom;
      s.activitiesTo = new Date(s.activitiesFrom);
      addDays(s.activitiesTo, 7);
      s.tableColPos.idx = 0;
      fullRecomputation = true;
    } else {
      s.tableColPos.idx = numDays - 1;
    }
  }
  if (fullRecomputation) {
    recomputeDurations(s);
  } else {
    recomputeActivityFilter(s);
  }
}
function recomputeDurations(s) {
  recomputeAllNoteDurations(state, s.activitiesFrom, s.activitiesTo);
  const hltMap = /* @__PURE__ */ new Map();
  for (let i = state._activitiesFromIdx; i >= 0 && i <= state._activitiesToIdx; i++) {
    const activity = state.activities[i];
    const nextActivity = state.activities[i + 1];
    const durationMs = getActivityDurationMs(activity, nextActivity);
    if (s.hideBreaks && isBreak(activity)) {
      continue;
    }
    const nId = activity.nId;
    if (!nId) {
      continue;
    }
    const note = getNote(state.notes, nId);
    const hlt = getHigherLevelTask(state, note);
    if (!hlt) {
      continue;
    }
    let block = hltMap.get(hlt.id);
    if (!block) {
      block = { hlt, slots: [], name: "" };
      block.name = getNoteTextWithoutPriority(block.hlt.data);
      const numDays = getNumDays(s);
      for (let i2 = 0; i2 < numDays; i2++) {
        block.slots.push({
          time: 0,
          activityIndices: []
        });
      }
      hltMap.set(hlt.id, block);
    }
    const dayOfWeek = getActivityTime(activity).getDay();
    if (s.scope === "week") {
      assert(block.slots.length === 7);
      block.slots[dayOfWeek].time += durationMs;
      block.slots[dayOfWeek].activityIndices.push(i);
    } else {
      assert(block.slots.length === 1);
      block.slots[0].time += durationMs;
      block.slots[0].activityIndices.push(i);
    }
    hltMap.set(hlt.id, block);
  }
  s.durations = [...hltMap.values()].sort((a, b) => {
    const aTotal = a.slots[a.slots.length - 1].time;
    const bTotal = b.slots[b.slots.length - 1].time;
    return bTotal - aTotal;
  });
  if (s.tableRowPos.idx >= s.durations.length) {
    s.tableRowPos.idx = 0;
  }
  if (s.tableColPos.idx >= getNumDays(s)) {
    s.tableColPos.idx = 0;
  }
  recomputeActivityFilter(s);
}
function recomputeActivityFilter(s) {
  let rowIdx = s.tableRowPos.idx;
  let colIdx = s.tableColPos.idx;
  function getFilter() {
    if (s.durations.length === 0) return [];
    if (rowIdx !== -1 && colIdx !== -1) {
      const row = s.durations[rowIdx];
      assert(!!row);
      const cell = row.slots[colIdx];
      assert(!!cell);
      return [...cell.activityIndices];
    }
    if (rowIdx !== -1) {
      const row = s.durations[rowIdx];
      assert(!!row);
      return row.slots.flatMap((s2) => s2.activityIndices);
    }
    if (colIdx !== -1) {
      return s.durations.flatMap((d) => mustGetDefined(d.slots[colIdx].activityIndices));
    }
    return s.durations.flatMap((d) => d.slots.flatMap((s2) => s2.activityIndices));
  }
  s.activityFilter = getFilter();
}
function imDurationsView(c, ctx, s) {
  const viewHasFocus = ctx.currentView === s;
  if (viewHasFocus) {
    handleKeyboardInput$5(ctx, s);
  }
  if (imMemo(c, viewHasFocus)) {
    if (!s.activitiesTo && !s.activitiesFrom) {
      s.activitiesFrom = /* @__PURE__ */ new Date();
      floorDateToWeekLocalTime(s.activitiesFrom);
      s.activitiesTo = new Date(s.activitiesFrom.getTime());
      addDays(s.activitiesTo, 7);
    }
    recomputeDurations(s);
    setActivityRangeToThisWeek(state);
    setTableRow(ctx, s, s.tableRowPos.idx);
  }
  ctx.views.activities.inputs.activityFilter = s.activityFilter;
  imLayout(c, COL);
  imFlex(c);
  {
    let tableState;
    tableState = imGet(c, inlineTypeId(imLayout));
    if (!tableState) tableState = imSet(c, {
      lastMaxWidth: 0,
      maxWidth: 0,
      recomputedPrevFrame: false
    });
    if (tableState.recomputedPrevFrame) {
      tableState.maxWidth = 50;
    }
    const allRowsSelected = s.tableRowPos.idx === -1;
    const allColsSelected = s.tableColPos.idx === -1;
    const allSelected = allRowsSelected && allColsSelected;
    imListRowBegin(c, allSelected, viewHasFocus && allSelected);
    {
      imLayout(c, ROW);
      imFlex(c);
      imAlign(c);
      {
        imLayout(c, BLOCK);
        imFlex(c);
        imLayoutEnd(c);
        imLayout(c, BLOCK);
        {
          imB(c);
          {
            imStr(c, "Duration Timesheet - ");
            imStr(c, formatDate(s.activitiesFrom, true));
            imStr(c, " to ");
            imStr(c, formatDate(s.activitiesTo, true));
          }
          imBEnd(c);
        }
        imLayoutEnd(c);
        imLayout(c, BLOCK);
        imFlex(c);
        imLayoutEnd(c);
      }
      imLayoutEnd(c);
      imLine(c, LINE_VERTICAL, 1);
      const numDays = getNumDays(s);
      imFor(c);
      for (let colIdx = 0; colIdx < numDays; colIdx++) {
        imLayout(c, BLOCK);
        {
          const colSelectedIndividual = s.tableColPos.idx === colIdx;
          const colSelected = colSelectedIndividual || allColsSelected;
          imListCursorBg(
            c,
            getRowStatus(colSelected, viewHasFocus && allRowsSelected)
          );
          imLayout(c, BLOCK);
          imSize(c, 0, NA, 7, PX);
          {
            imListCursorColor(
              c,
              getRowStatus(colSelected, viewHasFocus && colSelectedIndividual)
            );
          }
          imLayoutEnd(c);
          imLayout(c, BLOCK);
          imListRowCellStyle(c);
          {
            if (imMemo(c, tableState.lastMaxWidth)) {
              elSetStyle(c, "width", tableState.lastMaxWidth + "px");
            }
            let str = DAYS_OF_THE_WEEK_ABBREVIATED[colIdx];
            const span = imB(c).root;
            imStr(c, str);
            imBEnd(c);
            if (tableState.recomputedPrevFrame) {
              tableState.maxWidth = Math.max(tableState.maxWidth, span.scrollWidth);
            }
          }
          imLayoutEnd(c);
        }
        imLayoutEnd(c);
      }
      imForEnd(c);
    }
    imEndListRowNoPadding(c);
    imLine(c, LINE_HORIZONTAL, 1);
    const list = imNavListBegin(c, s.scrollContainer, s.tableRowPos.idx, viewHasFocus);
    {
      while (imNavListNextItemArray(list, s.durations)) {
        const { i: rowIdx } = list;
        const block = s.durations[rowIdx];
        const rowSelectedIndividual = s.tableRowPos.idx === rowIdx;
        const rowSelected = rowSelectedIndividual || allRowsSelected;
        const root = imLayout(c, ROW);
        {
          imLayout(c, BLOCK);
          {
            if (isFirstishRender(c)) {
              elSetStyle(c, "width", "10px");
            }
            imListCursorColor(
              c,
              getRowStatus(rowSelectedIndividual, viewHasFocus && rowSelectedIndividual)
            );
          }
          imLayoutEnd(c);
          imLayout(c, BLOCK);
          imFlex(c);
          imListRowCellStyle(c);
          {
            const selected = (rowSelected || allRowsSelected) && allColsSelected;
            imListCursorBg(
              c,
              getRowStatus(rowSelected, viewHasFocus && selected)
            );
            imStr(c, block.name);
          }
          imLayoutEnd(c);
          imLine(c, LINE_VERTICAL, 1);
          imFor(c);
          for (let colIdx = 0; colIdx < block.slots.length; colIdx++) {
            const slot = block.slots[colIdx];
            const colSelectedIndividual = s.tableColPos.idx === colIdx;
            const colSelected = colSelectedIndividual || allColsSelected;
            const cellSelected = (rowSelected || allRowsSelected) && (colSelected || allColsSelected);
            imLayout(c, BLOCK);
            imListRowCellStyle(c);
            {
              imListCursorBg(
                c,
                getRowStatus(rowSelected || colSelected, viewHasFocus && cellSelected)
              );
              if (imMemo(c, tableState.lastMaxWidth)) {
                elSetStyle(c, "width", tableState.lastMaxWidth + "px");
              }
              const span = imLayout(c, INLINE);
              {
                if (tableState.recomputedPrevFrame) {
                  tableState.maxWidth = Math.max(tableState.maxWidth, span.scrollWidth);
                }
                imStr(c, formatDurationAsHours(slot.time));
              }
              imLayoutEnd(c);
            }
            imLayoutEnd(c);
          }
          imForEnd(c);
        }
        imLayoutEnd(c);
        if (rowSelectedIndividual && list.scrollContainer) {
          scrollToItem(c, list.scrollContainer, root);
        }
      }
    }
    imNavListEnd(c, list);
    tableState.recomputedPrevFrame = !!imMemo(c, s.durations);
    tableState.lastMaxWidth = tableState.maxWidth;
  }
  imLayoutEnd(c);
}
const SCOPE_EVERTHING = 0;
const SCOPE_CHILDREN = 1;
const SCOPE_SHALLOW_PARENTS = 2;
const SCOPE_COUNT = 3;
function getNextScope(scope) {
  return (scope + 1) % SCOPE_COUNT;
}
function scopeToString(nextScope) {
  switch (nextScope) {
    case SCOPE_EVERTHING:
      return "Everything";
    case SCOPE_CHILDREN:
      return "Children";
    case SCOPE_SHALLOW_PARENTS:
      return "Parents";
  }
  throw new Error("Scope's name not known: " + nextScope);
}
function newFuzzyFindState() {
  return {
    query: "",
    matches: [],
    exactMatchSucceeded: false,
    counts: {
      numInProgress: 0,
      numFinished: 0,
      numShelved: 0
    },
    currentIdx: 0,
    scope: SCOPE_EVERTHING
  };
}
function searchAllNotesForText(state2, rootNote, query, dstMatches, {
  fuzzySearch,
  traverseUpwards
}) {
  dstMatches.length = 0;
  if (query.length === 0) return;
  const SORT_BY_SCORE = 1;
  const SORT_BY_RECENCY = 2;
  let sortMethod = SORT_BY_SCORE;
  const isShelvedQuery = query.startsWith("||");
  if (isShelvedQuery) {
    query = query.substring(2).trim();
  }
  const isHltQuery = query.startsWith(">>");
  const isInProgressQuery = query.startsWith(">") && !isHltQuery;
  if (isHltQuery) {
    query = query.substring(2).trim();
  } else if (isInProgressQuery) {
    query = query.substring(1).trim();
  }
  if (isHltQuery || isInProgressQuery || isShelvedQuery) {
    if (query.trim().length === 0) {
      sortMethod = SORT_BY_RECENCY;
    }
  }
  const processNote = (n) => {
    if (idIsNil(n.parentId)) {
      return;
    }
    let text = n.data.text.toLowerCase();
    if (isShelvedQuery || isHltQuery || isInProgressQuery) {
      if (isShelvedQuery !== isNoteRequestingShelf(n.data)) {
        return;
      }
      if (isShelvedQuery && isHltQuery) {
        if (!isNoteRequestingShelf(n.data)) {
          return;
        }
        const parent = getNoteOrUndefined(state2.notes, n.parentId);
        if (parent && parent.data._shelved) {
          return;
        }
      }
      if (isHltQuery && !isHigherLevelTask(n)) {
        return;
      }
      if (isInProgressQuery && isHigherLevelTask(n)) {
        return;
      }
      if (isHltQuery || isInProgressQuery) {
        if (n.data._status !== STATUS_IN_PROGRESS) {
          return;
        }
      }
    }
    if (sortMethod === SORT_BY_SCORE && query.trim().length > 0) {
      let results = fuzzyFind(text, query, { allowableMistakes: fuzzySearch ? 1 : 0 });
      if (results.ranges.length > 0) {
        let score = 0;
        score = results.score;
        if (n.data._status === STATUS_IN_PROGRESS) {
          score *= 2;
        }
        dstMatches.push({
          note: n,
          ranges: results.ranges,
          score
        });
      }
    } else {
      let score = n.data._activityListMostRecentIdx;
      dstMatches.push({
        note: n,
        ranges: null,
        score
      });
    }
  };
  if (idIsRoot(rootNote.id) || !traverseUpwards) {
    dfsPre(state2, rootNote, processNote);
  } else {
    forEachParentNote(state2.notes, rootNote, (note) => forEachChildNote(state2, note, processNote));
  }
  dstMatches.sort((a, b) => {
    return b.score - a.score;
  });
}
function newFuzzyFinderViewState() {
  return {
    fuzzyFindState: newFuzzyFindState(),
    timeTakenMs: 0,
    scrollContainer: newScrollContainer()
  };
}
function setIdx$2(ctx, s, idx) {
  var _a;
  const matches = s.fuzzyFindState.matches;
  if (matches.length === 0) return;
  s.fuzzyFindState.currentIdx = clampedListIdx(idx, matches.length);
  const match = matches[s.fuzzyFindState.currentIdx];
  setCurrentNote(state, match.note.id, (_a = ctx.noteBeforeFocus) == null ? void 0 : _a.id);
}
function handleKeyboardInput$4(ctx, s) {
  const finderState = s.fuzzyFindState;
  const matches = finderState.matches;
  const listNavigation = getNavigableListInput(
    ctx,
    s.fuzzyFindState.currentIdx,
    0,
    matches.length,
    AXIS_VERTICAL,
    AXIS_FLAG_BYPASS_TEXT_AREA
  );
  if (listNavigation) {
    setIdx$2(ctx, s, listNavigation.newIdx);
  }
  if (hasDiscoverableCommand(ctx, ctx.keyboard.enterKey, "Go to note", BYPASS_TEXT_AREA)) {
    setCurrentView(ctx, ctx.views.noteTree);
  }
  const nextScope = getNextScope(finderState.scope);
  if (ctx.noteBeforeFocus && hasDiscoverableCommand(ctx, ctx.keyboard.fKey, "Scope search to " + scopeToString(nextScope), CTRL | BYPASS_TEXT_AREA)) {
    finderState.scope = nextScope;
  }
  if (hasDiscoverableCommand(ctx, ctx.keyboard.enterKey, "Newline", SHIFT | BYPASS_TEXT_AREA)) {
    ctx.handled = false;
  }
}
function recomputeFuzzyFinderMatches(ctx, finderState) {
  const dst = finderState.matches;
  dst.length = 0;
  const rootNote = finderState.scope === SCOPE_EVERTHING ? getRootNote(state) : finderState.scope === SCOPE_CHILDREN ? ctx.noteBeforeFocus : ctx.noteBeforeFocus;
  if (!rootNote) return;
  searchAllNotesForText(state, rootNote, finderState.query, dst, {
    fuzzySearch: false,
    traverseUpwards: finderState.scope === SCOPE_SHALLOW_PARENTS
  });
  finderState.exactMatchSucceeded = dst.length > 0;
  if (!finderState.exactMatchSucceeded) {
    searchAllNotesForText(state, rootNote, finderState.query, dst, {
      fuzzySearch: true,
      traverseUpwards: finderState.scope === SCOPE_SHALLOW_PARENTS
    });
  }
  const MAX_MATCHES = 100;
  if (dst.length > MAX_MATCHES) {
    dst.length = MAX_MATCHES;
  }
  const counts = finderState.counts;
  counts.numFinished = 0;
  counts.numInProgress = 0;
  counts.numShelved = 0;
  for (const match of dst) {
    if (match.note.data._status === STATUS_IN_PROGRESS) {
      counts.numInProgress++;
    } else {
      counts.numFinished++;
    }
    if (match.note.data._shelved) {
      counts.numShelved++;
    }
  }
}
function recomputeTraversal$1(ctx, s) {
  recomputeFuzzyFinderMatches(ctx, s.fuzzyFindState);
  setIdx$2(ctx, s, s.fuzzyFindState.currentIdx);
}
function imFuzzyFinder(c, ctx, s) {
  const finderState = s.fuzzyFindState;
  const viewHasFocus = ctx.currentView === s;
  if (viewHasFocus) {
    handleKeyboardInput$4(ctx, s);
  }
  const viewHasFocusChanged = imMemo(c, viewHasFocus);
  if (viewHasFocusChanged && viewHasFocus) {
    finderState.scope = SCOPE_EVERTHING;
  }
  const queryChanged = imMemo(c, finderState.query);
  const scopeChanged = imMemo(c, finderState.scope);
  let t0 = 0;
  if (queryChanged || scopeChanged) {
    t0 = performance.now();
    s.timeTakenMs = 0;
    recomputeTraversal$1(ctx, s);
  }
  imLayout(c, COL);
  imFlex(c);
  {
    imLayout(c, ROW);
    imListRowCellStyle(c);
    imJustify(c);
    {
      if (isFirstishRender(c)) {
        elSetStyle(c, "fontWeight", "bold");
      }
      let scope = scopeToString(finderState.scope);
      imStr(c, `Finder [${scope}]`);
    }
    imLayoutEnd(c);
    imListRowBegin(c, viewHasFocus, viewHasFocus, true);
    {
      imLayout(c, ROW);
      imFlex(c);
      imListRowCellStyle(c);
      {
        const [, textArea] = imTextAreaBegin(c, {
          value: finderState.query
        });
        {
          const input = imOn(c, EV_INPUT);
          const change = imOn(c, EV_CHANGE);
          if (input || change) {
            finderState.query = textArea.value;
            ctx.handled = true;
          }
          if (viewHasFocusChanged && viewHasFocus) {
            ctx.textAreaToFocus = textArea;
            ctx.focusWithAllSelected = false;
          }
        }
        imTextAreaEnd(c);
      }
      imLayoutEnd(c);
    }
    imListRowEnd(c);
    if (imIf(c) && finderState.query.length > 0 && !finderState.exactMatchSucceeded) {
      imLayout(c, ROW);
      imListRowCellStyle(c);
      {
        imStr(c, `Found 0 exact matches, fell back to a fuzzy search`);
      }
      imLayoutEnd(c);
    }
    imIfEnd(c);
    const list = imNavListBegin(
      c,
      s.scrollContainer,
      s.fuzzyFindState.currentIdx,
      viewHasFocus
    );
    {
      const matches = s.fuzzyFindState.matches;
      while (imNavListNextItemArray(list, matches)) {
        const { i } = list;
        const item = matches[i];
        imNavListRowBegin(c, list);
        {
          imLayout(c, BLOCK);
          imListRowCellStyle(c);
          {
            if (imIf(c) && item.ranges) {
              let diffState;
              diffState = imGet(c, inlineTypeId(imFuzzyFinder));
              if (!diffState) diffState = imSet(c, {
                text: "",
                ranges: []
              });
              if (imMemo(c, item)) {
                let text = item.note.data.text;
                let ranges = item.ranges;
                if (item.ranges.length > 0) {
                  const contextWindow = 10;
                  let matchStart = item.ranges[0][0] - contextWindow;
                  let truncateStart = matchStart !== 0;
                  if (matchStart < 0) {
                    matchStart = 0;
                    truncateStart = false;
                  }
                  let matchEnd = item.ranges[item.ranges.length - 1][1] + contextWindow;
                  let truncateEnd = matchEnd !== text.length;
                  if (matchEnd > text.length) {
                    matchEnd = text.length;
                    truncateEnd = false;
                  }
                  text = text.substring(matchStart, matchEnd);
                  let rangeOffset = matchStart;
                  if (truncateStart) {
                    text = "... " + text;
                    rangeOffset -= "... ".length;
                  }
                  if (truncateEnd) text = text + " ...";
                  ranges = ranges.map((r) => [r[0] - rangeOffset, r[1] - rangeOffset]);
                }
                diffState.ranges = ranges;
                diffState.text = text;
              }
              {
                let lastStart = 0;
                const { text, ranges } = diffState;
                imFor(c);
                for (let i2 = 0; i2 < ranges.length; i2++) {
                  const [start, nextLastStart] = ranges[i2];
                  const beforeHighlighted = text.substring(lastStart, start);
                  const highlighted = text.substring(start, nextLastStart);
                  lastStart = nextLastStart;
                  imLayout(c, INLINE);
                  {
                    if (isFirstishRender(c)) {
                      elSetClass(c, cnApp.defocusedText);
                    }
                    imStr(c, beforeHighlighted);
                  }
                  imLayoutEnd(c);
                  imLayout(c, INLINE);
                  imStr(c, highlighted);
                  imLayoutEnd(c);
                }
                imForEnd(c);
                if (imIf(c) && lastStart !== text.length) {
                  imLayout(c, INLINE);
                  {
                    if (isFirstishRender(c)) {
                      elSetClass(c, cnApp.defocusedText);
                    }
                    imStr(c, text.substring(lastStart));
                  }
                  imLayoutEnd(c);
                }
                imIfEnd(c);
              }
            } else {
              imIfElse(c);
              imLayout(c, INLINE);
              imStr(c, truncate(item.note.data.text, 50));
              imLayoutEnd(c);
            }
            imIfEnd(c);
          }
          imLayoutEnd(c);
        }
        imNavListRowEnd(c);
      }
    }
    imNavListEnd(c, list);
    imLayout(c, ROW);
    imJustify(c);
    {
      const numMatches = finderState.matches.length;
      const resultType = finderState.exactMatchSucceeded ? "exact" : "fuzzy";
      const yourWelcome = numMatches === 0 ? " (you're welcome)" : "";
      imStr(c, `Narrowed ${state.notes.nodes.length} to ${numMatches} ${resultType} results in ${s.timeTakenMs}ms${yourWelcome}`);
    }
    imLayoutEnd(c);
  }
  imLayoutEnd(c);
  if (queryChanged || scopeChanged) {
    s.timeTakenMs = performance.now() - t0;
  }
}
const PARTIAL_INVALIDATION = 1;
const FULL_INVALIDATION = 2;
function setNote(s, note, invalidate = false) {
  s.invalidateNote = 0;
  let mutated = false;
  if (invalidate || s.note !== note) {
    if (s.note !== note) {
      mutated || (mutated = deleteNoteIfEmpty(state, s.note));
      invalidate || (invalidate = mutated);
    }
    s.note = note;
    setCurrentNote(state, note.id);
    recomputeVisibleNotes(s);
  }
  if (invalidate) {
    recomputeNoteStatusRecursively(state, note);
  }
}
function recomputeNoteParents(state2, flatNotes, currentNote) {
  flatNotes.length = 0;
  let note = currentNote;
  while (!idIsNil(note.parentId)) {
    flatNotes.push(note);
    note = getNote(state2.notes, note.parentId);
  }
  flatNotes.reverse();
}
function recomputeFlatNotes(state2, flatNotes, viewRoot, currentNote) {
  flatNotes.length = 0;
  const dfs = (note) => {
    flatNotes.push(note);
    let isVisualLeaf = note.childIds.length === 0;
    if (!isVisualLeaf) {
      const collapsed = isNoteCollapsed(note);
      if (collapsed) {
        isVisualLeaf = true;
        if (collapsed === COLLAPSED_STATUS) {
          const currentNoteIsInsideThisOne = currentNote !== note && // don't want to see through the current note
          parentNoteContains(state2, note.id, currentNote);
          if (currentNoteIsInsideThisOne) {
            isVisualLeaf = false;
          }
        }
      }
    }
    if (isVisualLeaf) {
      return;
    }
    for (const childId of note.childIds) {
      const note2 = getNote(state2.notes, childId);
      dfs(note2);
    }
  };
  for (const childId of viewRoot.childIds) {
    const note = getNote(state2.notes, childId);
    dfs(note);
  }
}
function recomputeVisibleNotes(s) {
  s.invalidateVisibleNotes = false;
  if (s.scrollContainer) startScrolling(s.scrollContainer, true);
  recomputeNoteParents(state, s.noteParentNotes, s.note);
  const viewRoot = getNoteViewRoot(state, s.note);
  if (s.viewRoot !== viewRoot) {
    s.viewRoot = viewRoot;
    s.stickyNotes.length = 0;
    if (s.scrollContainer) startScrolling(s.scrollContainer, false);
    recomputeNoteParents(state, s.viewRootParentNotes, s.viewRoot);
  }
  recomputeFlatNotes(state, s.childNotes, s.viewRoot, s.note);
  s.listPos.idx = s.childNotes.indexOf(s.note);
}
function getNoteViewRoot(state2, currentNote) {
  let it = currentNote;
  while (!idIsNil(it.parentId)) {
    it = getNote(state2.notes, it.parentId);
    const collapsed = isNoteCollapsed(it);
    if (collapsed && collapsed !== COLLAPSED_STATUS) {
      break;
    }
  }
  return it;
}
function newNoteTreeViewState() {
  const note = getCurrentNote(state);
  const viewRoot = note;
  const s = {
    invalidateNote: 0,
    invalidateVisibleNotes: false,
    note,
    viewRoot,
    noteParentNotes: [],
    stickyNotes: [],
    viewRootParentNotes: [],
    childNotes: [],
    scrollContainer: newScrollContainer(),
    listPos: newListPosition(),
    numVisible: 0
  };
  setNote(s, s.note, true);
  return s;
}
function moveOutOfCurrent(ctx, s, moveNote) {
  if (idIsNilOrRoot(s.note.parentId)) return;
  const parent = getNote(state.notes, s.note.parentId);
  if (moveNote) {
    if (!idIsNil(parent.parentId)) {
      const parentParent = getNote(state.notes, parent.parentId);
      const parentIdx = parent.idxInParentList;
      insertAt(state.notes, parentParent, s.note, parentIdx + 1);
      setNote(s, s.note, true);
      recomputeNoteStatusRecursively(state, parent);
      debouncedSave(ctx, state, "Moved a note");
    }
  } else {
    setNote(s, parent, false);
  }
}
function moveIntoCurrent(ctx, s, moveNote) {
  if (!boundsCheck(s.childNotes, s.listPos.idx)) return;
  if (idIsNil(s.note.parentId)) return;
  if (moveNote) {
    const parentIdx = s.note.idxInParentList;
    if (parentIdx !== 0) {
      const parent = getNote(state.notes, s.note.parentId);
      const prevNoteId = parent.childIds[parentIdx - 1];
      const prevNote = getNote(state.notes, prevNoteId);
      let idxUnderPrev = clampedListIdx(
        prevNote.data.lastSelectedChildIdx + 1,
        prevNote.childIds.length
      ) + 1;
      insertAt(state.notes, prevNote, s.note, idxUnderPrev);
      prevNote.data.lastSelectedChildIdx = idxUnderPrev;
      setNote(s, s.note, true);
      recomputeNoteStatusRecursively(state, prevNote);
      notesMutated(state);
    }
  } else {
    const nextRoot = s.childNotes[s.listPos.idx];
    if (nextRoot.childIds.length > 0) {
      if (!boundsCheck(nextRoot.childIds, nextRoot.data.lastSelectedChildIdx)) {
        nextRoot.data.lastSelectedChildIdx = nextRoot.childIds.length - 1;
      }
      const nextChildId = nextRoot.childIds[nextRoot.data.lastSelectedChildIdx];
      const nextChild = getNote(state.notes, nextChildId);
      setNote(s, nextChild, false);
    }
  }
}
function imNoteTreeView(c, ctx, s) {
  const viewFocused = ctx.currentView === s;
  {
    const currentNote = getCurrentNote(state);
    if (imMemo(c, currentNote)) {
      s.note = getCurrentNote(state);
      s.invalidateNote = PARTIAL_INVALIDATION;
    }
  }
  {
    if (s.invalidateNote) {
      setNote(s, s.note, s.invalidateNote === FULL_INVALIDATION);
    }
    if (s.invalidateVisibleNotes) {
      recomputeVisibleNotes(s);
    }
  }
  if (viewFocused) {
    handleKeyboardInput$3(ctx, s);
  }
  imLayout(c, COL);
  imFlex(c);
  {
    imLayout(c, BLOCK);
    {
      s.numVisible = 0;
      imFor(c);
      for (const row of s.viewRootParentNotes) {
        imKeyedBegin(c, row);
        {
          imNoteTreeRow(c, ctx, null, s, row, viewFocused);
        }
        imKeyedEnd(c);
      }
      imForEnd(c);
    }
    imLayoutEnd(c);
    imLine(
      c,
      LINE_HORIZONTAL,
      1,
      !!s.scrollContainer.root && s.scrollContainer.root.scrollTop > 1
    );
    imLayout(c, BLOCK);
    {
      imFor(c);
      for (const row of s.stickyNotes) {
        imKeyedBegin(c, row);
        {
          imNoteTreeRow(c, ctx, null, s, row, viewFocused);
        }
        imKeyedEnd(c);
      }
      imForEnd(c);
    }
    imLayoutEnd(c);
    const list = imNavListBegin(c, s.scrollContainer, s.listPos.idx, viewFocused, state._isEditingFocusedNote);
    {
      while (imNavListNextItemArray(list, s.childNotes)) {
        const { i, itemSelected } = list;
        const note = s.childNotes[i];
        const root = imNoteTreeRow(c, ctx, list, s, note, viewFocused, i, itemSelected);
        if (s.noteParentNotes.includes(note) && s.scrollContainer.root) {
          if (!s.stickyNotes.includes(note) && getElementExtentNormalized(s.scrollContainer.root, root, EXTENT_VERTICAL | EXTENT_END) < 0) {
            s.stickyNotes.push(note);
          } else if (s.stickyNotes.includes(note) && getElementExtentNormalized(s.scrollContainer.root, root, EXTENT_VERTICAL | EXTENT_START) > 0) {
            filterInPlace(s.stickyNotes, (n) => n !== note);
          }
        }
      }
      imKeyedBegin(c, "scrolloff");
      {
        imLayout(c, BLOCK);
        imSize(c, 0, NA, 500, PX);
        imLayoutEnd(c);
      }
      imKeyedEnd(c);
    }
    imNavListEnd(c, list);
    imLine(c, LINE_HORIZONTAL, 1);
    const currentNote = getCurrentNote(state);
    imLayout(c, ROW);
    imGap(c, 10, PX);
    {
      imLayout(c, BLOCK);
      imStr(c, "Created " + formatDateTime(currentNote.data.openedAt));
      imLayoutEnd(c);
      imLayout(c, BLOCK);
      imStr(c, "|");
      imLayoutEnd(c);
      imLayout(c, BLOCK);
      imStr(c, "Last Edited " + formatDateTime(currentNote.data.editedAt));
      imLayoutEnd(c);
    }
    imLayoutEnd(c);
  }
  imLayoutEnd(c);
}
const UNDER = 1;
const AFTER = 2;
function addNoteAtCurrent(ctx, s, insertType) {
  assert(!idIsNil(s.note.parentId));
  const currentNote = getCurrentNote(state);
  assert(!isNoteEmpty(currentNote));
  const newNote = createNewNote(state, "");
  if (insertType === UNDER) {
    addUnder(state.notes, s.note, newNote);
  } else if (insertType === AFTER) {
    addAfter(state.notes, s.note, newNote);
  } else {
    assert(false);
  }
  recomputeNoteStatusRecursively(state, newNote);
  return newNote;
}
function moveToLocalidx(ctx, s, idx, moveNote) {
  if (idIsNil(s.note.parentId)) return;
  const parent = getNote(state.notes, s.note.parentId);
  idx = clampedListIdx(idx, parent.childIds.length);
  if (!boundsCheck(parent.childIds, idx)) return;
  if (moveNote) {
    insertAt(state.notes, parent, s.note, idx);
    setNote(s, s.note, true);
    recomputeNoteStatusRecursively(state, s.note);
    notesMutated(state);
  } else {
    const childId = parent.childIds[idx];
    const note = getNote(state.notes, childId);
    setNote(s, note, false);
  }
}
function handleKeyboardInput$3(ctx, s) {
  const { keyboard } = ctx;
  const currentNote = getCurrentNote(state);
  const parent = getNote(state.notes, currentNote.parentId);
  if (state._isEditingFocusedNote) {
    if (hasDiscoverableCommand(ctx, keyboard.escapeKey, "Stop editing", BYPASS_TEXT_AREA)) {
      setIsEditingCurrentNote(state, false);
    }
  }
  if (hasDiscoverableCommand(ctx, keyboard.tKey, "Fast-travel")) {
    setCurrentView(ctx, ctx.views.fastTravel);
  }
  if (!state._isEditingFocusedNote) {
    if (!ctx.handled) {
      const moveNote = keyboard.altKey.held;
      const listNavInput = getNavigableListInput(ctx, currentNote.idxInParentList, 0, parent.childIds.length);
      if (listNavInput) {
        moveToLocalidx(ctx, s, listNavInput.newIdx, moveNote);
      } else if (keyboard.leftKey.pressed) {
        moveOutOfCurrent(ctx, s, moveNote);
        ctx.handled = true;
      } else if (keyboard.rightKey.pressed) {
        moveIntoCurrent(ctx, s, moveNote);
        ctx.handled = true;
      }
    }
    if (hasDiscoverableCommand(ctx, keyboard.aKey, "Note activity", REPEAT)) {
      const idx = findLastIndex(state.activities, (a) => a.nId === state.currentNoteId && !a.deleted);
      if (idx !== -1) {
        activitiesViewSetIdx(ctx, ctx.views.activities, idx, NOT_IN_RANGE);
        setCurrentView(ctx, ctx.views.activities);
      }
    }
    if (hasDiscoverableCommand(ctx, keyboard.slashKey, "URLs", CTRL)) {
      setCurrentView(ctx, ctx.views.urls);
    }
  }
  {
    let noteToSet;
    if (!isNoteEmpty(currentNote)) {
      if (hasDiscoverableCommand(ctx, keyboard.enterKey, "Insert note after", SHIFT | BYPASS_TEXT_AREA)) {
        noteToSet = addNoteAtCurrent(ctx, s, AFTER);
      } else if (hasDiscoverableCommand(ctx, keyboard.enterKey, "Insert note under", CTRL | BYPASS_TEXT_AREA)) {
        noteToSet = addNoteAtCurrent(ctx, s, UNDER);
      }
    }
    if (noteToSet) {
      setNote(s, noteToSet, true);
      setIsEditingCurrentNote(state, true);
      ctx.handled = true;
    }
  }
  if (!state._isEditingFocusedNote) {
    if (hasDiscoverableCommand(ctx, keyboard.enterKey, "Edit note")) {
      setIsEditingCurrentNote(state, true);
    }
  }
}
function imNoteTreeRow(c, ctx, list, s, note, viewFocused, idx = -1, itemSelected = false) {
  s.numVisible++;
  let numInProgress = 0;
  let numDone = 0;
  for (const id of note.childIds) {
    const note2 = getNote(state.notes, id);
    if (note2.data._status === STATUS_IN_PROGRESS) {
      numInProgress++;
    } else {
      numDone++;
    }
  }
  const root = imNavListRowBegin(c, list);
  {
    imLayout(c, ROW);
    imFlex(c);
    {
      if (imMemo(c, itemSelected)) {
        elSetClass(c, cn.preWrap, itemSelected);
      }
      imLayout(c, ROW_REVERSE);
      {
        const noteIsParent = s.noteParentNotes.includes(note) || idIsRoot(note.id);
        let it = note;
        let foundLineInPath = false;
        imFor(c);
        while (!idIsNil(it.parentId)) {
          const itPrev = it;
          const itPrevNumSiblings = getNumSiblings(state, itPrev);
          it = getNote(state.notes, it.parentId);
          const itIsParent = s.noteParentNotes.includes(it) || idIsRoot(it.id);
          const isLineInPath = !foundLineInPath && idx <= s.listPos.idx && itIsParent;
          foundLineInPath || (foundLineInPath = isLineInPath);
          const hasHLine = itPrev.id === note.id;
          const indent = 30;
          const bulletStart = 5;
          const smallThicnkess = 1;
          const largeThicnkess = 4;
          const isLast = itPrev.idxInParentList === itPrevNumSiblings - 1;
          let pathGoesRight = noteIsParent || it.id === note.id;
          {
            imLayout(c, BLOCK);
            imRelative(c);
            imSize(c, indent, PX, 0, NA);
            {
              if (imIf(c) && hasHLine) {
                imLayout(c, BLOCK);
                imAbsolute(c, 0, NA, 0, PX, 1, EM, 0, NA);
                {
                  if (isFirstishRender(c)) {
                    elSetStyle(c, "transform", "translate(0, -100%)");
                  }
                  const isThick = isLineInPath && pathGoesRight;
                  imSize(
                    c,
                    bulletStart,
                    PX,
                    isThick ? largeThicnkess : smallThicnkess,
                    PX
                  );
                  imBg(c, cssVarsApp.fgColor);
                }
                imLayoutEnd(c);
              }
              imIfEnd(c);
              const canDrawVerticalLine = !isLast || note === itPrev;
              if (imIf(c) && canDrawVerticalLine) {
                let midpointLen = 1;
                let midpointUnits = EM;
                imLayout(c, BLOCK);
                imAbsolute(c, 0, NA, bulletStart, PX, 0, PX, 0, isLast ? NA : PX);
                {
                  imSize(
                    c,
                    isLineInPath ? largeThicnkess : smallThicnkess,
                    PX,
                    midpointLen,
                    midpointUnits
                  );
                  imBg(c, cssVarsApp.fgColor);
                }
                imLayoutEnd(c);
                imLayout(c, BLOCK);
                {
                  const isThick = isLineInPath && !pathGoesRight;
                  imAbsolute(c, 0, NA, bulletStart, PX, midpointLen, midpointUnits, 0, isLast ? NA : PX);
                  imSize(
                    c,
                    isThick ? largeThicnkess : smallThicnkess,
                    PX,
                    0,
                    NA
                  );
                  imOpacity(c, isLast ? 0 : 1);
                  imBg(c, cssVarsApp.fgColor);
                }
                imLayoutEnd(c);
              }
              imIfEnd(c);
            }
            imLayoutEnd(c);
          }
        }
        imForEnd(c);
      }
      imLayoutEnd(c);
      imLayout(c, ROW);
      imFlex(c);
      imListRowCellStyle(c);
      {
        if (imMemo(c, note.data._status)) {
          elSetStyle(c, "color", note.data._status === STATUS_IN_PROGRESS ? "" : cssVarsApp.unfocusTextColor);
        }
        imLayout(c, ROW);
        imFlex(c);
        {
          if (imMemo(c, itemSelected)) {
            elSetClass(c, cn.preWrap, itemSelected);
            elSetClass(c, cn.pre, !itemSelected);
            elSetClass(c, cn.noWrap, !itemSelected);
            elSetClass(c, cn.overflowHidden, !itemSelected);
          }
          imLayout(c, ROW);
          {
            if (isFirstishRender(c)) {
              elSetClass(c, cn.noWrap);
            }
            imLayout(c, BLOCK);
            imStr(c, noteStatusToString(note.data._status));
            imLayoutEnd(c);
            if (imIf(c) && numInProgress + numDone > 0) {
              imLayout(c, BLOCK);
              imSize(c, 0.5, CH, 0, NA);
              imLayoutEnd(c);
              imStr(c, `(${numDone}/${numInProgress + numDone})`);
            }
            imIfEnd(c);
            imLayout(c, BLOCK);
            imSize(c, 0.5, CH, 0, NA);
            imLayoutEnd(c);
          }
          imLayoutEnd(c);
          const isEditing = viewFocused && itemSelected && state._isEditingFocusedNote;
          const isEditingChanged = imMemo(c, isEditing);
          if (imIf(c) && isEditing) {
            const [, textArea] = imTextAreaBegin(c, {
              value: note.data.text
            });
            {
              const input = imOn(c, EV_INPUT);
              const change = imOn(c, EV_CHANGE);
              if (input || change) {
                let status = s.note.data._status;
                let collapseStatus = isNoteCollapsed(s.note);
                setNoteText(state, s.note, textArea.value);
                ctx.handled = true;
                if (status !== s.note.data._status || collapseStatus !== isNoteCollapsed(s.note)) {
                  s.invalidateNote = FULL_INVALIDATION;
                }
              }
              const keyDown = imOn(c, EV_KEYDOWN);
              if (keyDown) {
                ctx.handled = doExtraTextAreaInputHandling(keyDown, textArea, {
                  tabStopSize: state.settings.tabStopSize,
                  useSpacesInsteadOfTabs: state.settings.spacesInsteadOfTabs
                });
              }
              if (isEditingChanged) {
                textArea.selectionStart = textArea.value.length;
                textArea.selectionEnd = textArea.value.length;
              }
              ctx.textAreaToFocus = textArea;
            }
            imTextAreaEnd(c);
          } else {
            imIfElse(c);
            const textChanged = imMemo(c, note.data.text);
            let text = imGet(c, String);
            if (text === void 0 || textChanged) {
              let val = note.data.text;
              if (val.length > 150) {
                val = `[${val.length}ch] - ${val}`;
              }
              text = imSet(c, val);
            }
            imStr(c, text);
          }
          imIfEnd(c);
        }
        imLayoutEnd(c);
      }
      imLayoutEnd(c);
    }
    imLayoutEnd(c);
  }
  imNavListRowEnd(c);
  return root;
}
function newNoteTraversalViewState() {
  return {
    viewRoot: null,
    notes: [],
    scrollContainer: newScrollContainer(),
    listPosition: newListPosition()
  };
}
function setIdx$1(ctx, s, idx) {
  var _a;
  s.listPosition.idx = clampedListIdx(idx, s.notes.length);
  const note = get(s.notes, s.listPosition.idx);
  if (note) {
    setCurrentNote(state, note.id, (_a = ctx.noteBeforeFocus) == null ? void 0 : _a.id);
  }
}
function handleKeyboardInput$2(ctx, s) {
  const current = getCurrentNote(state);
  const listNavigation = getNavigableListInput(ctx, s.listPosition.idx, 0, s.notes.length);
  if (listNavigation) {
    setIdx$1(ctx, s, listNavigation.newIdx);
  }
  if (s.viewRoot && hasDiscoverableCommand(ctx, ctx.keyboard.leftKey, "Move out", REPEAT)) {
    recomputeTraversal(s, s.viewRoot.id, false);
  }
  if (isHigherLevelTask(current) && current.childIds.length > 0 && hasDiscoverableCommand(ctx, ctx.keyboard.rightKey, "Move in", REPEAT)) {
    recomputeTraversal(s, current.childIds[0], false);
  }
  if (hasDiscoverableCommand(ctx, ctx.keyboard.enterKey, "Go to note")) {
    setCurrentView(ctx, ctx.views.noteTree);
  }
}
function recomputeTraversal(s, noteId, useNotePosition) {
  s.notes.length = 0;
  const note = getNote(state.notes, noteId);
  s.viewRoot = getNoteViewRoot(state, note);
  const dfs = (note2, doThing) => {
    if (doThing) {
      if (note2.data._status === STATUS_IN_PROGRESS) {
        const isHlt = isHigherLevelTask(note2);
        if (note2.childIds.length === 0 || isHlt) {
          s.notes.push(note2);
          return;
        }
      }
    }
    for (const id of note2.childIds) {
      const child = getNote(state.notes, id);
      dfs(child, true);
    }
  };
  dfs(s.viewRoot, false);
  s.notes.sort((a, b) => b.data.editedAt.getTime() - a.data.editedAt.getTime());
  const idx = s.notes.indexOf(note);
  if (useNotePosition && idx !== -1) {
    s.listPosition.idx = idx;
  } else if (s.notes.length > 0) {
    s.listPosition.idx = 0;
    noteId = s.notes[0].id;
  }
  if (state.currentNoteId !== noteId) {
    setCurrentNote(state, noteId);
  }
}
function imNoteTraversal(c, ctx, s) {
  const viewHasFocus = ctx.currentView === s;
  if (viewHasFocus) {
    handleKeyboardInput$2(ctx, s);
  }
  if (imMemo(c, state._notesMutationCounter)) recomputeTraversal(s, state.currentNoteId, true);
  imLayout(c, COL);
  imListRowCellStyle(c);
  imAlign(c);
  {
    if (isFirstishRender(c)) {
      elSetStyle(c, "fontWeight", "bold");
    }
    imLayout(c, BLOCK);
    imStr(c, "Fast travel");
    imLayoutEnd(c);
    if (imIf(c) && s.viewRoot) {
      imLayout(c, BLOCK);
      imStr(c, s.viewRoot.data.text);
      imLayoutEnd(c);
    }
    imIfEnd(c);
  }
  imLayoutEnd(c);
  imLine(c, LINE_HORIZONTAL, 1);
  let renderedAny = false;
  const list = imNavListBegin(c, s.scrollContainer, s.listPosition.idx, viewHasFocus);
  {
    while (imNavListNextItemArray(list, s.notes)) {
      renderedAny = true;
      const { i } = list;
      const note = s.notes[i];
      imNavListRowBegin(c, list);
      {
        imLayout(c, BLOCK);
        imListRowCellStyle(c);
        {
          imLayout(c, INLINE);
          {
            const canGoIn = note.childIds.length > 0;
            if (imMemo(c, canGoIn)) {
              elSetStyle(c, "fontWeight", canGoIn ? "bold" : "");
            }
            const text = note.data.text;
            imStr(c, text);
          }
          imLayoutEnd(c);
        }
        imLayoutEnd(c);
      }
      imNavListRowEnd(c);
    }
    imKeyedBegin(c, "empty");
    {
      if (imIf(c) && !renderedAny) {
        imLayout(c, ROW);
        imFlex(c);
        imAlign(c);
        imJustify(c);
        {
          imStr(c, "This level has been cleared!");
        }
        imLayoutEnd(c);
      }
      imIfEnd(c);
    }
    imKeyedEnd(c);
  }
  imNavListEnd(c, list);
}
function imAppHeadingBegin(c) {
  imElBegin(c, EL_H1);
  imPadding(c, 10, PX, 0, NA, 0, NA, 0, NA);
  {
    if (isFirstishRender(c)) {
      elSetStyle(c, "textOverflow", "ellipsis");
      elSetStyle(c, "fontSize", "28px");
    }
  }
}
function imAppHeadingEnd(c) {
  imElEnd(c, EL_H1);
}
const saveFile = async (blob, suggestedName) => {
  const supportsFileSystemAccess = "showSaveFilePicker" in window && (() => {
    try {
      return window.self === window.top;
    } catch {
      return false;
    }
  })();
  if (supportsFileSystemAccess) {
    try {
      const handle = await showSaveFilePicker({
        suggestedName
      });
      const writable = await handle.createWritable();
      await writable.write(blob);
      await writable.close();
      return;
    } catch (err) {
      if (err.name !== "AbortError") {
        console.error(err.name, err.message);
        return;
      }
    }
  }
  const blobURL = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = blobURL;
  a.download = suggestedName;
  a.style.display = "none";
  document.body.append(a);
  a.click();
  setTimeout(() => {
    URL.revokeObjectURL(blobURL);
    a.remove();
  }, 1e3);
};
function downloadTextAsFile(text, suggestedName) {
  const fileBlob = new Blob([text], { type: "text/plain" });
  saveFile(fileBlob, suggestedName);
}
function loadFile(handler) {
  const uploadInput = document.createElement("INPUT");
  uploadInput.setAttribute("type", "file");
  uploadInput.click();
  uploadInput.addEventListener("change", () => {
    var _a;
    const file = (_a = uploadInput.files) == null ? void 0 : _a[0];
    if (!file) {
      handler(null);
    } else {
      handler(file);
    }
  });
}
const REQUIRED_PRESSES = 5;
function newSettingsViewState() {
  return {
    mainListHasFocus: false,
    selectedMenu: null
  };
}
function importModal() {
  return {
    filename: "",
    state: null,
    acceptPresses: 0,
    imported: false
  };
}
function resetImportModal(state2) {
  state2.filename = "";
  state2.state = null;
  state2.acceptPresses = 0;
  state2.imported = false;
}
const menus = [
  {
    name: "UI",
    desc: "Fine-tune UI interactions",
    imComponent: (c, ctx, s, hasFocus) => {
      imLayout(c, COL);
      imFlex(c);
      {
        imLayout(c, COL);
        imFlex(c);
        imAlign(c);
        imJustify(c);
        {
          let vSc = imGet(c, newScrollContainer);
          if (!vSc) vSc = imSet(c, newScrollContainer());
          let vPos = imGet(c, newListPosition);
          if (!vPos) vPos = imSet(c, newListPosition());
          const settings = state.settings;
          const itemList = imNavListBegin(c, vSc, vPos.idx, hasFocus, false);
          {
            imNavListNextItem(itemList);
            {
              imNavListRowBegin(c, itemList);
              {
                imLayout(c, ROW);
                imListRowCellStyle(c);
                {
                  imB(c);
                  imStr(c, "Spaces or tabs?");
                  imBEnd(c);
                  imLayout(c, BLOCK);
                  imSize(c, 20, PX, 0, NA);
                  imLayoutEnd(c);
                  imStr(c, settings.spacesInsteadOfTabs ? "Spaces" : "Tabs");
                }
                imLayoutEnd(c);
              }
              imNavListRowEnd(c);
              if (hasFocus && itemList.itemSelected) {
                if (hasDiscoverableCommand(ctx, ctx.keyboard.enterKey, "Toggle")) {
                  settings.spacesInsteadOfTabs = !settings.spacesInsteadOfTabs;
                  debouncedSave(ctx, state, "Settings");
                }
              }
            }
            imNavListNextItem(itemList);
            {
              let canWiden = hasFocus && settings.tabStopSize < 12;
              let canNarrow = hasFocus && settings.tabStopSize > 1;
              imNavListRowBegin(c, itemList);
              {
                imLayout(c, ROW);
                imListRowCellStyle(c);
                {
                  if (isFirstishRender(c)) {
                    elSetClass(c, cn.preWrap);
                  }
                  imB(c);
                  imStr(c, "Tab width");
                  imBEnd(c);
                  imLayout(c, BLOCK);
                  imSize(c, 20, PX, 0, NA);
                  imLayoutEnd(c);
                  imStr(c, canNarrow ? "< " : "  ");
                  imStr(c, settings.tabStopSize);
                  imStr(c, " ".repeat(settings.tabStopSize));
                  imStr(c, canWiden ? ">" : "|");
                }
                imLayoutEnd(c);
              }
              imNavListRowEnd(c);
              if (hasFocus && itemList.itemSelected) {
                if (canWiden && hasDiscoverableCommand(ctx, ctx.keyboard.rightKey, "Wider")) {
                  settings.tabStopSize++;
                  debouncedSave(ctx, state, "settings");
                }
                if (canNarrow && hasDiscoverableCommand(ctx, ctx.keyboard.leftKey, "Narrower")) {
                  settings.tabStopSize--;
                  debouncedSave(ctx, state, "settings");
                }
              }
            }
          }
          imNavListEnd(c, itemList);
          if (hasFocus) {
            const vListInput = getNavigableListInput(ctx, vPos.idx, 0, itemList.i + 1);
            if (vListInput) {
              vPos.idx = vListInput.newIdx;
            }
          }
        }
        imLayoutEnd(c);
      }
      imLayoutEnd(c);
    }
  },
  {
    name: "Download JSON",
    desc: "Export your data to a JSON file to import later/elsewhere",
    imComponent: (c, ctx, s, hasFocus) => {
      imLayout(c, COL);
      imFlex(c);
      {
        imLayout(c, COL);
        imFlex(c);
        imAlign(c);
        imJustify(c);
        {
          let errRef;
          errRef = imGet(c, inlineTypeId(imTry));
          if (!errRef) errRef = imSet(c, { val: null });
          if (imIf(c) && !errRef.val) {
            imLayout(c, BLOCK);
            imListRowCellStyle(c);
            imB(c);
            imStr(c, state.notes.nodes.length + " notes");
            imBEnd(c);
            imLayoutEnd(c);
            imLayout(c, BLOCK);
            imListRowCellStyle(c);
            imB(c);
            imStr(c, state.activities.length + " activities");
            imBEnd(c);
            imLayoutEnd(c);
            imListRowBegin(c, true, hasFocus, false);
            {
              imLayout(c, BLOCK);
              imListRowCellStyle(c);
              {
                imElBegin(c, EL_B);
                imStr(c, "Download JSON");
                imElEnd(c, EL_B);
              }
              imLayoutEnd(c);
            }
            imListRowEnd(c);
            if (hasDiscoverableCommand(ctx, ctx.keyboard.enterKey, "Download JSON")) {
              try {
                downloadTextAsFile(
                  getCurrentStateAsJSON(),
                  `Note-Tree Backup - ${formatDateTime(/* @__PURE__ */ new Date(), "-").replace(/\//g, "-")}.json`
                );
              } catch (e) {
                errRef.val = e;
              }
            }
          } else {
            imIfElse(c);
            imLayout(c, BLOCK);
            imStr(c, "An error occured: " + errRef.val);
            imLayoutEnd(c);
            if (hasDiscoverableCommand(ctx, ctx.keyboard.escapeKey, "Dismiss")) {
              errRef.val = null;
            }
          }
          imIfEnd(c);
        }
        imLayoutEnd(c);
      }
      imLayoutEnd(c);
    }
  },
  {
    name: "Load from JSON",
    desc: "Import your data from a JSON file you exported",
    imComponent: (c, ctx, s, hasFocus) => {
      imLayout(c, COL);
      imFlex(c);
      {
        imLayout(c, COL);
        imFlex(c);
        imAlign(c);
        imJustify(c);
        {
          let importModalState = imGet(c, importModal);
          if (!importModalState) importModalState = imSet(c, importModal());
          if (imMemo(c, hasFocus)) {
            resetImportModal(importModalState);
          }
          const loadResult = importModalState.state;
          if (imIf(c) && loadResult) {
            let current = imGet(c, newFocusRef);
            if (!current) current = imSet(c, newFocusRef());
            const navList = imViewsList(c, current);
            imLayout(c, BLOCK);
            {
              const loadedState = loadResult.state;
              if (imIf(c) && loadedState) {
                const lastOnline = parseDateSafe(loadedState.breakAutoInsertLastPolledTime);
                imLayout(c, ROW);
                imJustify(c);
                {
                  imB(c);
                  imStr(c, "Make sure this looks reasonable before you load the backup");
                  imBEnd(c);
                }
                imLayoutEnd(c);
                imLayout(c, BLOCK);
                imSize(c, 0, NA, 30, PX);
                imLayoutEnd(c);
                imLayout(c, BLOCK);
                {
                  imB(c);
                  imStr(c, "Filename: ");
                  imLayoutEnd(c);
                  imStr(c, importModalState.filename);
                  imBEnd(c);
                }
                imLayoutEnd(c);
                imLayout(c, BLOCK);
                imB(c);
                imStr(c, "Notes: ");
                imLayoutEnd(c);
                imStr(c, loadedState.notes.nodes.length);
                imBEnd(c);
                imLayout(c, BLOCK);
                imB(c);
                imStr(c, "Activities: ");
                imLayoutEnd(c);
                imStr(c, loadedState.activities.length);
                imBEnd(c);
                imLayout(c, BLOCK);
                imB(c);
                imStr(c, "Last Online: ");
                imLayoutEnd(c);
                imStr(c, !lastOnline ? "No idea" : formatDateTime(lastOnline));
                imBEnd(c);
                imLayout(c, BLOCK);
                imB(c);
                imStr(c, "Last Theme: ");
                imLayoutEnd(c);
                imStr(c, loadedState.currentTheme);
                imBEnd(c);
                imLayout(c, BLOCK);
                imSize(c, 0, NA, 30, PX);
                imLayoutEnd(c);
                imLayout(c, ROW);
                imGap(c, 50, PX);
                {
                  addView(navList, 0, "Accept button");
                  {
                    const focused = current.focused === 0;
                    imListRowBegin(c, focused, focused && hasFocus, false);
                    {
                      imLayout(c, BLOCK);
                      imListRowCellStyle(c);
                      {
                        imB(c);
                        imStr(c, "Accept");
                        imBEnd(c);
                      }
                      imLayoutEnd(c);
                    }
                    imListRowEnd(c);
                    if (focused && hasDiscoverableCommand(ctx, ctx.keyboard.enterKey, "Reject")) {
                      importModalState.acceptPresses++;
                      if (importModalState.acceptPresses >= REQUIRED_PRESSES && !importModalState.imported) {
                        setState(loadedState);
                        saveCurrentState(ctx, state, { debounced: false });
                        setCurrentView(ctx, ctx.views.noteTree);
                      }
                    }
                  }
                  addView(navList, 1, "Reject button");
                  {
                    const focused = current.focused === 1;
                    imListRowBegin(c, focused, focused && hasFocus, false);
                    {
                      imLayout(c, BLOCK);
                      imListRowCellStyle(c);
                      {
                        imB(c);
                        imStr(c, "Reject");
                        imBEnd(c);
                      }
                      imLayoutEnd(c);
                    }
                    imListRowEnd(c);
                    if (focused && hasDiscoverableCommand(ctx, ctx.keyboard.enterKey, "Reject")) {
                      resetImportModal(importModalState);
                    }
                  }
                }
                imLayoutEnd(c);
                if (imIf(c) && importModalState.acceptPresses > 0) {
                  imLayout(c, BLOCK);
                  imB(c);
                  imListRowCellStyle(c);
                  imStr(c, "Your existing data will be wiped and replaced with this new state");
                  imLayoutEnd(c);
                  imBEnd(c);
                  imLayout(c, ROW);
                  imGap(c, 10, PX);
                  imSize(c, 100, PERCENT, 30, PX);
                  imAlign(c, STRETCH);
                  {
                    const countChanged = imMemo(c, importModalState.acceptPresses);
                    const col = "rgb(0, 255, 20)";
                    imFor(c);
                    for (let i = 0; i < REQUIRED_PRESSES; i++) {
                      imLayout(c, BLOCK);
                      imFlex(c);
                      {
                        if (countChanged) {
                          elSetStyle(
                            c,
                            "backgroundColor",
                            importModalState.acceptPresses >= REQUIRED_PRESSES ? col : importModalState.acceptPresses > i ? cssVarsApp.fgColor : ""
                          );
                        }
                      }
                      imLayoutEnd(c);
                    }
                    imForEnd(c);
                  }
                  imLayoutEnd(c);
                }
                imIfEnd(c);
              } else {
                imIfElse(c);
                imLayout(c, BLOCK);
                {
                  imLayout(c, BLOCK);
                  imB(c);
                  imStr(c, "An error occured while loading the file. It cannot be imported.");
                  imLayoutEnd(c);
                  imBEnd(c);
                  imLayout(c, BLOCK);
                  imStr(c, loadResult.error ?? loadResult.criticalError ?? "unknown error");
                  imLayoutEnd(c);
                }
                imLayoutEnd(c);
                addView(navList, 0, "Back button");
                {
                  const focused = current.focused === 0;
                  imListRowBegin(c, focused, hasFocus && focused, false);
                  {
                    imLayout(c, BLOCK);
                    imListRowCellStyle(c);
                    {
                      imB(c);
                      imStr(c, "Back");
                      imBEnd(c);
                    }
                    imLayoutEnd(c);
                  }
                  imListRowEnd(c);
                  if (hasFocus && focused) {
                    if (hasDiscoverableCommand(ctx, ctx.keyboard.enterKey, "Back") || hasDiscoverableCommand(ctx, ctx.keyboard.escapeKey, "Back")) {
                      resetImportModal(importModalState);
                    }
                  }
                }
              }
              imIfEnd(c);
            }
            imLayoutEnd(c);
            {
              const prev = get(navList.views, navList.idx - 1);
              const next = get(navList.views, navList.idx + 1);
              const tabInput = getTabInput(
                ctx,
                prev ? "Go to " + prev.name : null,
                next ? "Go to " + next.name : null
              );
              if (tabInput < 0 && prev) {
                current.focused = prev.focusRef;
              } else if (tabInput > 0 && next) {
                current.focused = next.focusRef;
              }
            }
          } else {
            imIfElse(c);
            imListRowBegin(c, true, hasFocus, false);
            {
              imLayout(c, BLOCK);
              imListRowCellStyle(c);
              imB(c);
              imStr(c, "Import JSON");
              imBEnd(c);
              imLayoutEnd(c);
              if (hasDiscoverableCommand(ctx, ctx.keyboard.enterKey, "Import JSON")) {
                loadFile((file) => {
                  if (!file) {
                    return;
                  }
                  file.text().then((text) => {
                    importModalState.filename = file.name;
                    importModalState.state = loadStateFromJSON(text);
                  });
                });
              }
            }
            imListRowEnd(c);
          }
          imIfEnd(c);
        }
        imLayoutEnd(c);
      }
      imLayoutEnd(c);
    }
  },
  // I'm not sure why you would ever want to do this in practice.
  // Like. Why would I ever delete my years worth of notes? Doesn't make any sense.
  // It's great for development tho.
  // Maybe for when you're moving computers or something, and you don't want to leave any data in the database?.
  {
    name: "Clear",
    desc: "Clear all your data, and start fresh",
    imComponent: (c, ctx, s, hasFocus) => {
      imLayout(c, COL);
      imFlex(c);
      {
        imLayout(c, COL);
        imFlex(c);
        imAlign(c);
        imJustify(c);
        {
          imLayout(c, BLOCK);
          imSize(c, 0, NA, 50, PX);
          imLayoutEnd(c);
          imLayout(c, BLOCK);
          imListRowCellStyle(c);
          {
            imB(c);
            {
              imStr(c, "Be sure to download your JSON");
              imI(c);
              imStr(c, " before ");
              imIEnd(c);
              imStr(c, "you do this.");
            }
            imBEnd(c);
          }
          imLayoutEnd(c);
          imLayout(c, BLOCK);
          imSize(c, 0, NA, 50, PX);
          imLayoutEnd(c);
          const focusChanged = imMemo(c, hasFocus);
          let clearDataState;
          clearDataState = imGet(c, inlineTypeId(imLayoutEnd));
          if (!clearDataState || focusChanged) clearDataState = imSet(c, {
            count: 0,
            wiped: false
          });
          const countChanged = imMemo(c, clearDataState.count);
          imListRowBegin(c, true, hasFocus, false);
          {
            imLayout(c, BLOCK);
            imListRowCellStyle(c);
            {
              if (isFirstishRender(c)) {
                elSetStyle(c, "fontSize", "30px");
              }
              const col = clearDataState.count < REQUIRED_PRESSES ? "red" : "white";
              elSetStyle(c, "color", col);
              imB(c);
              {
                imStr(c, "Delete all data");
              }
              imBEnd(c);
              imLayout(c, ROW);
              imGap(c, 10, PX);
              imSize(c, 100, PERCENT, 30, PX);
              imAlign(c, STRETCH);
              {
                imFor(c);
                for (let i = 0; i < REQUIRED_PRESSES; i++) {
                  imLayout(c, BLOCK);
                  imFlex(c);
                  {
                    if (countChanged) {
                      elSetStyle(
                        c,
                        "backgroundColor",
                        clearDataState.count >= REQUIRED_PRESSES ? col : clearDataState.count > i ? cssVarsApp.fgColor : ""
                      );
                    }
                  }
                  imLayoutEnd(c);
                }
                imForEnd(c);
              }
              imLayoutEnd(c);
            }
            imLayoutEnd(c);
            if (hasFocus) {
              if (hasDiscoverableCommand(ctx, ctx.keyboard.enterKey, "Delete all data")) {
                clearDataState.count++;
              }
            }
          }
          imListRowEnd(c);
          imLayout(c, BLOCK);
          imSize(c, 0, NA, 50, PX);
          imLayoutEnd(c);
          if (imIf(c) && clearDataState.count >= REQUIRED_PRESSES) {
            const REQUIRED_TIME_SECONDS = 1;
            const focusChanged2 = imMemo(c, hasFocus);
            let timer = imGet(c, Math.sin);
            if (timer === void 0 || focusChanged2) {
              timer = imSet(c, 0);
            }
            timer = imSet(c, timer + getDeltaTimeSeconds(c));
            imLayout(c, BLOCK);
            {
              if (isFirstishRender(c)) {
                elSetStyle(c, "fontSize", "30px");
                elSetStyle(c, "color", "red");
              }
              imB(c);
              {
                imStr(c, "SYSTEM WIPE IMMINENT");
              }
              imBEnd(c);
              imLayout(c, ROW);
              imAlign(c, STRETCH);
              imSize(c, 100, PERCENT, 30, PX);
              {
                imLayout(c, BLOCK);
                {
                  elSetStyle(c, "width", timer / REQUIRED_TIME_SECONDS * 100 + "%");
                  elSetStyle(c, "backgroundColor", "red");
                }
                imLayoutEnd(c);
              }
              imLayoutEnd(c);
            }
            imLayoutEnd(c);
            if (timer / REQUIRED_TIME_SECONDS > 1 && !clearDataState.wiped) {
              clearDataState.wiped = true;
              resetState();
              setCurrentView(ctx, null);
              setTimeout(() => {
                setCurrentView(ctx, ctx.views.noteTree);
              }, 1e3);
            }
          }
          imIfEnd(c);
        }
        imLayoutEnd(c);
      }
      imLayoutEnd(c);
    }
  }
];
function imSettingsView(c, ctx, s) {
  const viewHasFocus = ctx.currentView === s;
  let vPos = imGet(c, newListPosition);
  if (!vPos) vPos = imSet(c, newListPosition());
  if (imMemo(c, viewHasFocus) && viewHasFocus) {
    vPos.idx = 0;
    s.mainListHasFocus = false;
  }
  imLayout(c, COL);
  imFlex(c);
  {
    imLayout(c, COL);
    imAlign(c);
    imFlex(c);
    {
      imLayout(c, ROW);
      {
        imLayout(c, COL);
        {
          if (isFirstishRender(c)) {
            elSetStyle(c, "minWidth", "100px");
          }
          imLayout(c, ROW);
          imListRowCellStyle(c);
          imAlign(c);
          imJustify(c);
          {
            imB(c);
            imStr(c, "Settings");
            imBEnd(c);
          }
          imLayoutEnd(c);
          let vSc = imGet(c, newScrollContainer);
          if (!vSc) vSc = imSet(c, newScrollContainer());
          const hasFocus = viewHasFocus && !s.mainListHasFocus;
          const hallwayList = imNavListBegin(c, vSc, vPos.idx, hasFocus, false);
          {
            while (imNavListNextItemArray(hallwayList, menus)) {
              const menu = menus[hallwayList.i];
              if (hallwayList.itemSelected) {
                s.selectedMenu = menu;
              }
              imNavListRowBegin(c, hallwayList);
              {
                imLayout(c, BLOCK);
                imListRowCellStyle(c);
                {
                  imB(c);
                  imStr(c, menu.name);
                  imBEnd(c);
                }
                imLayoutEnd(c);
              }
              imNavListRowEnd(c);
            }
            if (hasFocus) {
              const vListInput = getNavigableListInput(ctx, vPos.idx, 0, hallwayList.i);
              if (vListInput) vPos.idx = vListInput.newIdx;
              if (s.selectedMenu && (hasDiscoverableCommand(ctx, ctx.keyboard.tabKey, "Go to " + s.selectedMenu.name, SHIFT) || hasDiscoverableCommand(ctx, ctx.keyboard.tabKey, "Go to " + s.selectedMenu.name) || hasDiscoverableCommand(ctx, ctx.keyboard.enterKey, "Go to " + s.selectedMenu.name))) {
                s.mainListHasFocus = true;
              }
            }
          }
          imNavListEnd(c, hallwayList);
        }
        imLayoutEnd(c);
        imLayout(c, BLOCK);
        imSize(c, 10, PX, 0, NA);
        imLayoutEnd(c);
        imLayout(c, COL);
        imFlex(c);
        {
          if (isFirstishRender(c)) {
            elSetStyle(c, "width", "800px");
          }
          imLayout(c, ROW);
          imAlign(c);
          imJustify(c);
          {
            imAppHeadingBegin(c);
            {
              let text = "Settings";
              if (s.selectedMenu) {
                text = s.selectedMenu.desc;
              }
              imStr(c, text);
            }
            imAppHeadingEnd(c);
          }
          imLayoutEnd(c);
          const mainListHasFocus = viewHasFocus && s.mainListHasFocus;
          imSwitch(c, s.selectedMenu);
          if (s.selectedMenu) s.selectedMenu.imComponent(c, ctx, s, mainListHasFocus);
          imSwitchEnd(c);
          if (mainListHasFocus) {
            if (hasDiscoverableCommand(ctx, ctx.keyboard.escapeKey, "Back to hallway") || hasDiscoverableCommand(ctx, ctx.keyboard.tabKey, "Back to hallway", SHIFT) || hasDiscoverableCommand(ctx, ctx.keyboard.tabKey, "Back to hallway")) {
              s.mainListHasFocus = false;
            }
          }
        }
        imLayoutEnd(c);
      }
      imLayoutEnd(c);
    }
    imLayoutEnd(c);
  }
  imLayoutEnd(c);
}
function forEachMatch(text, re, fn) {
  let match;
  while (match = re.exec(text)) {
    const start = match.index;
    const end = match.index + match[0].length;
    fn(match, start, end);
  }
}
function urlRegex() {
  return /(https|file):\S+\.\S+/g;
}
function forEachUrlPosition(text, fn) {
  forEachMatch(text, urlRegex(), (_, start, end) => fn(start, end));
}
function openUrlInNewTab(url) {
  var _a;
  if (!url.startsWith("https") && !url.startsWith("file")) {
    return;
  }
  (_a = window.open(url, "_blank")) == null ? void 0 : _a.focus();
}
function newUrlListViewState() {
  return {
    urls: [],
    scrollContainer: newScrollContainer(),
    listPosition: newListPosition()
  };
}
function setIdx(s, idx) {
  if (s.urls.length === 0) return;
  s.listPosition.idx = clampedListIdx(idx, s.urls.length);
  const url = s.urls[s.listPosition.idx];
  setCurrentNote(state, url.note.id);
}
function handleKeyboardInput$1(ctx, s) {
  const url = get(s.urls, s.listPosition.idx);
  const listNavigation = getNavigableListInput(ctx, s.listPosition.idx, 0, s.urls.length);
  if (listNavigation) {
    setIdx(s, listNavigation.newIdx);
  }
  if (url && hasDiscoverableCommand(ctx, ctx.keyboard.enterKey, "Open in new tab")) {
    openUrlInNewTab(url.url);
  }
}
function recomputeUrls(s) {
  s.urls.length = 0;
  function pushAllUrls(note) {
    forEachUrlPosition(note.data.text, (start, end) => {
      const url = note.data.text.substring(start, end);
      s.urls.push({
        url,
        note,
        range: [start, end]
      });
    });
  }
  const currentNote = getCurrentNote(state);
  let notes = [];
  let lastNote = currentNote;
  forEachParentNote(state.notes, currentNote, (note) => {
    forEachChildNote(state, note, (note2) => {
      if (note2 !== lastNote) {
        notes.push(note2);
      }
    });
    lastNote = note;
  });
  for (let i = notes.length - 1; i >= 0; i--) {
    pushAllUrls(notes[i]);
  }
  const wantedIdx = s.urls.length;
  dfsPre(state, currentNote, (note) => {
    pushAllUrls(note);
  });
  setIdx(s, wantedIdx);
}
function imUrlViewer(c, ctx, s) {
  const viewHasFocus = ctx.currentView === s;
  if (viewHasFocus) {
    handleKeyboardInput$1(ctx, s);
  }
  if (imMemo(c, viewHasFocus)) {
    recomputeUrls(s);
  }
  imLayout(c, COL);
  imListRowCellStyle(c);
  imAlign(c);
  {
    if (isFirstishRender(c)) {
      elSetStyle(c, "fontWeight", "bold");
    }
    imLayout(c, BLOCK);
    imStr(c, "Nearby URLs");
    imLayoutEnd(c);
  }
  imLayoutEnd(c);
  imLine(c, LINE_HORIZONTAL, 1);
  let renderedAny = false;
  const list = imNavListBegin(c, s.scrollContainer, s.listPosition.idx, viewHasFocus);
  {
    while (imNavListNextItemArray(list, s.urls)) {
      renderedAny = true;
      const { i } = list;
      const url = s.urls[i];
      imNavListRowBegin(c, list);
      {
        imLayout(c, BLOCK);
        imListRowCellStyle(c);
        {
          imElBegin(c, EL_A);
          {
            if (imMemo(c, url)) {
              elSetAttr(c, "href", url.url);
            }
            imStr(c, url.url);
          }
          imElEnd(c, EL_A);
        }
        imLayoutEnd(c);
      }
      imNavListRowEnd(c);
    }
    imKeyedBegin(c, "empty");
    {
      if (imIf(c) && !renderedAny) {
        imLayout(c, ROW);
        imFlex(c);
        imAlign(c);
        imJustify(c);
        {
          imStr(c, "No URLs found here.");
        }
        imLayoutEnd(c);
      }
      imIfEnd(c);
    }
    imKeyedEnd(c);
  }
  imNavListEnd(c, list);
}
function utf8ByteLength(str) {
  let s = str.length;
  for (let i = str.length - 1; i >= 0; i--) {
    const code = str.charCodeAt(i);
    if (code > 127 && code <= 2047) s++;
    else if (code > 2047 && code <= 65535) s += 2;
    if (code >= 56320 && code <= 57343) i--;
  }
  return s;
}
function bytesToMegabytes(bytes) {
  return bytes / 1024 / 1024;
}
const SAVE_DEBOUNCE = 1500;
function setCurrentView(ctx, view) {
  ctx.currentView = view;
  const currentNote = getNoteOrUndefined(state.notes, state.currentNoteId);
  if (currentNote) {
    ctx.noteBeforeFocus = currentNote;
  }
}
const TASK_IN_PROGRESS = 0;
const TASK_DONE = 1;
function newDiscoverableCommands() {
  const newCommandArray = () => Array(32).fill(null).map(() => {
    return {
      key: null,
      desc: "",
      flags: 0
    };
  });
  return {
    // only 8 discoverable commands at any given time MAX.
    thisFrame: newCommandArray(),
    stabilized: [],
    idx: 0,
    stabilizedIdx: 0,
    changed: false,
    stableFrames: 0,
    shiftAvailable: false,
    ctrlAvailable: false,
    altAvailable: false
  };
}
function newGlobalContext() {
  const keyboard = newKeyboardState();
  return {
    ev: newImGlobalEventSystem(),
    now: /* @__PURE__ */ new Date(),
    keyboard,
    handled: false,
    noteTreeViewState: newNoteTreeViewState(),
    textAreaToFocus: null,
    focusWithAllSelected: false,
    views: {
      noteTree: newNoteTreeViewState(),
      activities: newActivitiesViewState(),
      urls: newUrlListViewState(),
      fastTravel: newNoteTraversalViewState(),
      finder: newFuzzyFinderViewState(),
      settings: newSettingsViewState(),
      durations: newDurationsViewState()
      // canvas: newCanvasViewState(),
    },
    notLockedIn: true,
    requestSave: false,
    currentView: null,
    leftTab: null,
    viewingDurations: false,
    navListPrevious: { view: null, name: "" },
    navListNext: { view: null, name: "" },
    foundFocused: false,
    noteBeforeFocus: null,
    discoverableCommands: newDiscoverableCommands(),
    status: {
      statusTextTimeLeftSeconds: -1,
      statusTextTimeInitialSeconds: 1,
      statusText: "",
      statusTextType: TASK_IN_PROGRESS
    }
  };
}
const REPEAT = 1 << 0;
const CTRL = 1 << 1;
const SHIFT = 1 << 2;
const ALT = 1 << 3;
const HIDDEN = 1 << 4;
const BYPASS_TEXT_AREA = 1 << 5;
const ANY_MODIFIERS = 1 << 6;
function hasDiscoverableCommand(ctx, key, actionDescription, flags = 0) {
  const command = pushDiscoverableCommand(ctx, key, actionDescription, flags);
  if (!command) return false;
  if (hasCommand(ctx, command)) {
    ctx.handled = true;
    return true;
  }
  return false;
}
function hasCommand(ctx, command) {
  if (ctx.handled) return false;
  if (!(command.flags & BYPASS_TEXT_AREA) && isEditingTextSomewhereInDocument()) return false;
  if (!command.key || !command.key.pressed) return false;
  if (!(command.flags & REPEAT) && command.key.repeat) return false;
  if (!(command.flags & ANY_MODIFIERS)) {
    if (command.flags & ALT && !ctx.keyboard.altKey.held) return false;
    if (command.flags & CTRL && !ctx.keyboard.ctrlKey.held) return false;
    if (command.flags & SHIFT && !ctx.keyboard.shiftKey.held) return false;
  }
  return true;
}
function pushDiscoverableCommand(ctx, key, actionDescription, flags) {
  if (!(flags & BYPASS_TEXT_AREA) && isEditingTextSomewhereInDocument()) {
    return null;
  }
  const commands = ctx.discoverableCommands;
  if (commands.idx >= commands.thisFrame.length) return null;
  let found = false;
  for (let i = 0; i < commands.idx; i++) {
    const command2 = commands.thisFrame[i];
    if (command2.key === key && command2.flags === flags) {
      found = true;
      break;
    }
  }
  if (found) return null;
  const command = commands.thisFrame[commands.idx];
  command.desc = actionDescription;
  command.key = key;
  command.flags = flags;
  if (!(flags & ANY_MODIFIERS)) {
    const currentlyHeld = (ctx.keyboard.ctrlKey.held ? CTRL : 0) | (ctx.keyboard.shiftKey.held ? SHIFT : 0) | (ctx.keyboard.altKey.held ? ALT : 0);
    const commandWants = (CTRL | SHIFT | ALT) & flags;
    const excessKeys = currentlyHeld & ~commandWants;
    if (excessKeys) return null;
    const remainingToPress = commandWants & ~currentlyHeld;
    if (remainingToPress & CTRL) commands.ctrlAvailable = true;
    if (remainingToPress & SHIFT) commands.shiftAvailable = true;
    if (remainingToPress & ALT) commands.altAvailable = true;
    if (currentlyHeld !== commandWants) return null;
  }
  if (!(flags & HIDDEN)) {
    commands.idx++;
  }
  return command;
}
function newKeyState(stringRepresentation, key, key2) {
  return {
    stringRepresentation,
    key,
    key2,
    pressed: false,
    held: false,
    released: false,
    repeat: false,
    numPressed: 0,
    numHeld: 0,
    numReleased: 0
  };
}
function newKeyboardState() {
  const state2 = {
    keys: [],
    // CONSIDER: hjkl to move around, as well as arrows!
    upKey: newKeyState("↑", "ArrowUp"),
    downKey: newKeyState("↓", "ArrowDown"),
    leftKey: newKeyState("←", "ArrowLeft"),
    rightKey: newKeyState("→", "ArrowRight"),
    pageDownKey: newKeyState("PgDn", "PageDown"),
    pageUpKey: newKeyState("PgUp", "PageUp"),
    homeKey: newKeyState("Home", "Home"),
    endKey: newKeyState("End", "End"),
    spaceKey: newKeyState("Space", " "),
    slashKey: newKeyState("/", "?", "/"),
    commaKey: newKeyState(",", ",", "<"),
    aKey: newKeyState("A", "A", "a"),
    sKey: newKeyState("S", "S", "s"),
    dKey: newKeyState("D", "D", "d"),
    bKey: newKeyState("B", "B", "b"),
    tKey: newKeyState("T", "T", "t"),
    fKey: newKeyState("F", "F", "f"),
    enterKey: newKeyState("Enter", "Enter"),
    escapeKey: newKeyState("Esc", "Escape"),
    ctrlKey: newKeyState("Ctrl", "Control", "Meta"),
    shiftKey: newKeyState("Shift", "Shift"),
    altKey: newKeyState("Alt", "Alt"),
    tabKey: newKeyState("Tab", "Tab"),
    num0Key: newKeyState("0", "0"),
    num1Key: newKeyState("1", "1"),
    num2Key: newKeyState("2", "2"),
    num3Key: newKeyState("3", "3"),
    num4Key: newKeyState("4", "4"),
    num5Key: newKeyState("5", "5"),
    num6Key: newKeyState("6", "6"),
    num7Key: newKeyState("7", "7"),
    num8Key: newKeyState("8", "8"),
    num9Key: newKeyState("9", "9")
  };
  for (const k in state2) {
    const key = k;
    if (key !== "keys") state2.keys.push(state2[key]);
  }
  return state2;
}
function getAxisRaw(negative, positive) {
  let result = 0;
  if (negative) result -= 1;
  if (positive) result += 1;
  return result;
}
function pressKey(state2, repeat) {
  if (!repeat) {
    state2.numPressed++;
    state2.numHeld++;
  }
  state2.pressed = true;
  state2.repeat = repeat;
  state2.held = true;
}
function releaseKey(state2) {
  state2.numHeld--;
  state2.numReleased++;
  state2.held = state2.numHeld > 0;
  state2.released = true;
}
function stepKey(state2) {
  state2.numPressed = 0;
  state2.numReleased = 0;
  state2.pressed = false;
  state2.repeat = false;
  state2.released = false;
}
function resetKey(state2) {
  state2.numPressed = 0;
  state2.numHeld = 0;
  state2.numReleased = 0;
  state2.pressed = false;
  state2.held = state2.released = false;
}
function handleKeyDown(s, e) {
  for (let i = 0; i < s.keys.length; i++) {
    const key = s.keys[i];
    if (e.key === key.key || e.key === key.key2) {
      pressKey(key, e.repeat);
    }
  }
}
function handleKeyUp(s, e) {
  for (let i = 0; i < s.keys.length; i++) {
    const key = s.keys[i];
    if (e.key === key.key || e.key === key.key2) {
      releaseKey(key);
    }
  }
}
function stepKeyboardState(s) {
  for (let i = 0; i < s.keys.length; i++) {
    stepKey(s.keys[i]);
  }
}
function resetKeyboardState(s) {
  for (let i = 0; i < s.keys.length; i++) {
    resetKey(s.keys[i]);
  }
}
function handleImKeysInput(ctx, eventSystem) {
  const keyboard = ctx.keyboard;
  ctx.handled = false;
  const { keyDown, keyUp, blur } = eventSystem.keyboard;
  stepKeyboardState(keyboard);
  if (keyDown) {
    handleKeyDown(keyboard, keyDown);
  }
  if (keyUp) {
    handleKeyUp(keyboard, keyUp);
  }
  if (blur) {
    resetKeyboardState(keyboard);
  }
  return keyboard;
}
function preventImKeysDefault(ev) {
  const { keyDown, keyUp } = ev.keyboard;
  if (keyDown) keyDown.preventDefault();
  if (keyUp) keyUp.preventDefault();
}
function updateDiscoverableCommands(s) {
  var _a, _b;
  let changed = s.idx !== s.stabilizedIdx;
  for (let i = 0; i < s.idx; i++) {
    let equal = false;
    equal = ((_a = s.stabilized[i]) == null ? void 0 : _a.key) === s.thisFrame[i].key && ((_b = s.stabilized[i]) == null ? void 0 : _b.desc) === s.thisFrame[i].desc;
    if (!equal) changed = true;
  }
  if (changed && !s.changed) s.stableFrames = 0;
  s.changed || (s.changed = changed);
  if (changed) {
    const requiredStableFramesForSnapshot = 3;
    if (s.stableFrames < requiredStableFramesForSnapshot) {
      s.stableFrames++;
      if (s.stableFrames >= requiredStableFramesForSnapshot) {
        s.stabilizedIdx = s.idx;
        for (let i = 0; i < s.idx; i++) {
          s.stabilized[i] = { ...s.thisFrame[i] };
        }
        s.changed = false;
      }
    }
  }
  s.idx = 0;
}
const GITHUB_PAGE = "https://github.com/Tejas-H5/Working-on-Tree";
const GITHUB_PAGE_ISSUES = "https://github.com/Tejas-H5/Working-on-Tree/issues/new?template=Blank+issue";
console.log({
  github_page: GITHUB_PAGE,
  if_you_encounter_bugs: GITHUB_PAGE_ISSUES
});
let saveTimeout = 0;
function saveCurrentState(ctx, state2, { debounced } = { debounced: false }) {
  const thisState = state2;
  const save = () => {
    if (state2 !== thisState) {
      logTrace("The state changed unexpectedly! let's not save...");
      return;
    }
    applyPendingScratchpadWrites(thisState);
    saveState(thisState, (serialized) => {
      const bytes = utf8ByteLength(serialized);
      const mb = bytesToMegabytes(bytes);
      showStatusText(ctx, `Saved (` + mb.toFixed(2) + `mb)`, TASK_DONE);
      navigator.storage.estimate().then((data) => {
        state2.criticalSavingError = "";
        const estimatedMbUsage = bytesToMegabytes(data.usage ?? 0);
        if (estimatedMbUsage < 100) {
          return;
        }
        showStatusText(ctx, `Saved (` + mb.toFixed(2) + `mb / ` + estimatedMbUsage.toFixed(2) + `mb)`, TASK_DONE);
        const baseErrorMessage = "WARNING: Your browser is consuming SIGNIFICANTLY more disk space on this site than what should be required: " + estimatedMbUsage.toFixed(2) + "mb being used instead of an expected " + (mb * 2).toFixed(2) + "mb.";
        const COMPACTION_THRESHOLD = 20;
        const CRITICAL_ERROR_THRESHOLD = 40;
        if (mb * COMPACTION_THRESHOLD < estimatedMbUsage) {
          console.warn(baseErrorMessage);
        }
        if (mb * CRITICAL_ERROR_THRESHOLD < estimatedMbUsage) {
          const criticalSavingError = baseErrorMessage + " You should start backing up your data ever day, and anticipate a crash of some sort. Also consider using this website in another browser. This bug should be reported as a github issue on " + GITHUB_PAGE;
          state2.criticalSavingError = criticalSavingError;
          console.error(criticalSavingError);
        }
      });
    });
  };
  const debounceAmount = !debounced ? 10 : SAVE_DEBOUNCE;
  showStatusText(ctx, `Saving`, TASK_IN_PROGRESS, SAVE_DEBOUNCE);
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(() => {
    save();
  }, debounceAmount);
}
const STATUS_TEXT_PERSIST_TIME = 1e3;
function showStatusText(ctx, text, type, timeout = STATUS_TEXT_PERSIST_TIME) {
  ctx.status.statusText = text;
  ctx.status.statusTextType = type;
  ctx.status.statusTextTimeLeftSeconds = timeout / 1e3;
  ctx.status.statusTextTimeInitialSeconds = timeout / 1e3;
}
function debouncedSave(ctx, state2, where) {
  assert(!!where);
  logTrace("Save initiated via " + where);
  saveCurrentState(ctx, state2, { debounced: true });
}
function newTimeInputState() {
  return {
    text: "",
    // possibly not needed at all?
    valueBeforeEdit: null,
    value: null,
    textArea: null,
    edit: null
  };
}
function imEditableTime(c, currentValue, lowerBound = null, upperBound = null) {
  let textArea;
  if (upperBound && lowerBound) {
    assert(lowerBound.getTime() < upperBound.getTime());
  }
  let s = imGet(c, newTimeInputState);
  if (!s) s = imSet(c, newTimeInputState());
  s.textArea = null;
  s.edit = null;
  const idx = c[CACHE_IDX];
  [, textArea] = imTextAreaBegin(c, {
    value: s.text,
    placeholder: "Time"
  });
  {
    s.textArea = textArea;
    const focus = imOn(c, EV_FOCUS);
    const input = imOn(c, EV_INPUT);
    const change = imOn(c, EV_CHANGE);
    const keyDown = imOn(c, EV_KEYDOWN);
    if (
      // Refocus -> synced
      focus || // (
      //   First render  -> synced 
      //   Edited, it was applied  -> internal updated, text not synced
      //   Edited, it was not applied -> synced with the outside
      // ) 
      (s.value === null || s.value.getTime() !== (currentValue == null ? void 0 : currentValue.getTime()))
    ) {
      let setType = SET_INTERNAL_AND_TEXT;
      if (document.activeElement === textArea && !focus) {
        setType = SET_INTERNAL_ONLY;
      }
      setInnerValue(s, currentValue, lowerBound, upperBound, setType);
      if (setType === SET_INTERNAL_AND_TEXT) {
        setInputValue(textArea, s.text);
        textArea.select();
      }
    }
    if (input || change || keyDown) {
      if (input || change) {
        s.text = textArea.value.trim();
        s.edit = parseTimeEditEvent(s.text, currentValue);
      } else if (keyDown) {
        const up = keyDown.key === "ArrowUp";
        const down = keyDown.key === "ArrowDown";
        const altHeld = keyDown.altKey;
        if (up || down) {
          let timeIncrement = 5;
          if (altHeld) {
            timeIncrement = 30;
          }
          let editedDate = new Date(currentValue ?? /* @__PURE__ */ new Date());
          if (up) {
            roundToNearestMinutes(editedDate, timeIncrement);
            addMinutes(editedDate, timeIncrement);
          } else {
            roundToNearestMinutes(editedDate, timeIncrement);
            addMinutes(editedDate, -timeIncrement);
          }
          editedDate = clampDate(editedDate, lowerBound, upperBound);
          setInnerValue(s, editedDate, lowerBound, upperBound, SET_INTERNAL_AND_TEXT);
          s.edit = { timeInput: cloneDate(s.value) };
        }
      }
    }
  }
  imTextAreaEnd(c);
  assert(c[CACHE_IDX] === idx);
  return s;
}
const SET_INTERNAL_AND_TEXT = false;
const SET_INTERNAL_ONLY = true;
function setInnerValue(s, editedDate, lowerBound, upperBound, type) {
  s.value = editedDate ? clampDate(editedDate, lowerBound, upperBound) : null;
  if (type === SET_INTERNAL_AND_TEXT) {
    s.text = formatTimeForInput(s.value);
  }
}
function parseTimeEditEvent(text, currentDate, nextDate) {
  if (!currentDate) currentDate = /* @__PURE__ */ new Date();
  const [time, err] = parseTimeInput(text, currentDate);
  if (!err) {
    const result = new Date(currentDate);
    dateSetLocalTime(result, time);
    return { timeInput: result };
  }
  const [duration, err2] = parseDurationInput(text);
  if (!err2) {
    return { durationInput: duration };
  }
  return null;
}
const FOCUS_ACTIVITIES_LIST = 0;
const FOCUS_DATE_SELECTOR = 1;
const EDITING_NOTHING = 0;
const EDITING_TIME = 1;
const EDITING_ACTIVITY = 2;
function newActivitiesViewState() {
  return {
    inputs: { activityFilter: null },
    activities: [],
    filteredActivities: [],
    viewHasFocus: false,
    currentFocus: FOCUS_ACTIVITIES_LIST,
    activityListPositon: newListPosition(),
    isEditing: EDITING_NOTHING,
    scrollContainer: newScrollContainer(),
    now: /* @__PURE__ */ new Date(),
    currentViewingDate: /* @__PURE__ */ new Date(),
    _startActivityIdx: 0,
    _endActivityIdxEx: 0,
    _range: [0, 0],
    _canMoveToNextDay: false,
    _canMoveToPrevDay: false
  };
}
function getActivitiesForDateStartIdx(activities, date, startSeekingFrom = 0) {
  let i = startSeekingFrom;
  if (i >= activities.length) i = activities.length - 1;
  while (i >= 0) {
    if (activities[i].t < date && !isSameDate(activities[i].t, date)) break;
    if (i === 0) {
      return 0;
    }
    i--;
  }
  while (i < activities.length) {
    i++;
    if (i === activities.length) break;
    if (isSameDate(activities[i].t, date)) break;
  }
  return i;
}
function activitiesViewTakeBreak(ctx, s) {
  if (!isCurrentlyTakingABreak(state)) {
    pushBreakActivity(state, newBreakActivity("Taking a break...", /* @__PURE__ */ new Date(), NOT_IN_RANGE));
  }
  activitiesViewSetIdx(ctx, s, s.activities.length - 1, NOT_IN_RANGE);
  s.isEditing = EDITING_ACTIVITY;
  debouncedSave(ctx, state, activitiesViewTakeBreak.name);
}
function getActivitiesNextDateStartIdx(activities, startIdx) {
  if (!boundsCheck(activities, startIdx)) return startIdx;
  let i = startIdx;
  const date = activities[i].t;
  while (i < activities.length) {
    i++;
    if (i === activities.length) break;
    if (!isSameDate(activities[i].t, date)) break;
  }
  return i;
}
function getActivityRange(s) {
  s._startActivityIdx = getActivitiesForDateStartIdx(s.activities, s.currentViewingDate, s._startActivityIdx);
  s._endActivityIdxEx = getActivitiesNextDateStartIdx(s.activities, s._startActivityIdx);
  s._range[0] = s._startActivityIdx;
  s._range[1] = s._endActivityIdxEx;
  return s._range;
}
const IN_RANGE = false;
const NOT_IN_RANGE = true;
function moveToNextDay(ctx, s) {
  const [lo, hi] = getActivityRange(s);
  if (hi < s.activities.length - 1) {
    activitiesViewSetIdx(ctx, s, hi + 1, true);
  } else if (!s.filteredActivities && !isSameDate(s.now, s.currentViewingDate)) {
    setCurrentViewingDate(s, s.now);
  }
}
function moveToPrevDay(ctx, s) {
  const [lo, hi] = getActivityRange(s);
  if (lo > 0) {
    activitiesViewSetIdx(ctx, s, lo - 1, true);
  }
}
function activitiesViewSetIdx(ctx, s, idx, notInRange) {
  var _a;
  if (s.activities.length === 0) return;
  const lastIdx = s.activityListPositon.idx;
  let newIdx = idx;
  if (boundsCheck(s.activities, lastIdx)) {
    const lastActivity = s.activities[lastIdx];
    if (isBreak(lastActivity) && lastActivity.breakInfo !== void 0 && lastActivity.breakInfo.length === 0) {
      s.activities.splice(lastIdx, 1);
      if (newIdx >= lastIdx) {
        newIdx--;
      }
    }
  }
  if (notInRange) {
    newIdx = clampedListIdx(idx, s.activities.length);
  } else {
    const [lo, hi] = getActivityRange(s);
    newIdx = clampedListIdxRange(idx, lo, hi);
  }
  if (newIdx !== s.activityListPositon.idx) {
    s.activityListPositon.idx = newIdx;
    const activity = s.activities[newIdx];
    if (activity.nId) {
      setCurrentNote(state, activity.nId, (_a = ctx.noteBeforeFocus) == null ? void 0 : _a.id);
    }
  }
  if (s.activities.length > 0) {
    const activities = s.activities[newIdx];
    if (!isSameDate(activities.t, s.currentViewingDate)) {
      setCurrentViewingDate(s, activities.t);
    }
  }
}
function insertBreakBetweenCurrentAndNext(ctx, s) {
  if (s.filteredActivities) return;
  const idx = s.activityListPositon.idx;
  if (!boundsCheck(s.activities, idx)) return;
  const activity = s.activities[idx];
  const nextActivity = s.activities[idx + 1];
  const timeA = getActivityTime(activity).getTime();
  const duration = getActivityDurationMs(activity, nextActivity);
  const midpoint = timeA + duration / 2;
  const newBreak = newBreakActivity("New break", new Date(midpoint), false);
  s.activities.splice(idx + 1, 0, newBreak);
  debouncedSave(ctx, state, "Insert break activities list");
  s.isEditing = EDITING_ACTIVITY;
  activitiesViewSetIdx(ctx, s, idx + 1, IN_RANGE);
}
function handleKeyboardInput(ctx, s) {
  const { keyboard } = ctx;
  const [lo, hi] = getActivityRange(s);
  const currentActivity = get(s.activities, s.activityListPositon.idx);
  hasActivitiesToView(s);
  if (!hasActivitiesToView(s)) {
    s.currentFocus === FOCUS_DATE_SELECTOR;
  }
  if (s.currentFocus === FOCUS_DATE_SELECTOR) {
    s.isEditing = EDITING_NOTHING;
  }
  if (s.currentFocus === FOCUS_ACTIVITIES_LIST) {
    if (s.activityListPositon.idx === lo && hasDiscoverableCommand(ctx, keyboard.upKey, "Select date", REPEAT)) {
      s.currentFocus = FOCUS_DATE_SELECTOR;
    }
    if (!isSameDate(s.now, s.currentViewingDate) && s.activityListPositon.idx === s._endActivityIdxEx && hasDiscoverableCommand(ctx, keyboard.downKey, "Next day", REPEAT)) {
      s.currentFocus = FOCUS_DATE_SELECTOR;
      moveToNextDay(ctx, s);
    }
    if (s.isEditing === EDITING_NOTHING) {
      if (currentActivity && isBreak(currentActivity) && // !currentActivity.locked && // TODO: review this flag. Not sure what the point of it is.
      hasDiscoverableCommand(ctx, keyboard.enterKey, "Edit break")) {
        s.isEditing = EDITING_ACTIVITY;
      }
      if (currentActivity && !isBreak(currentActivity) && hasDiscoverableCommand(ctx, keyboard.enterKey, "Edit activity time")) {
        s.isEditing = EDITING_TIME;
      }
      if (hasDiscoverableCommand(ctx, keyboard.enterKey, "Insert break under", SHIFT)) {
        insertBreakBetweenCurrentAndNext(ctx, s);
      }
      const hDelta = getAxisRaw(keyboard.leftKey.pressed, keyboard.rightKey.pressed);
      if (!ctx.handled && hDelta) {
        ctx.handled = true;
        if (currentActivity == null ? void 0 : currentActivity.nId) {
          const note = getNote(state.notes, currentActivity.nId);
          const hlt = getHigherLevelTask(state, note);
          let foundIdx = -1;
          const dir = hDelta > 0 ? 1 : -1;
          for (let i = s.activityListPositon.idx + dir; i < s.activities.length && i >= 0; i += dir) {
            const activity = s.activities[i];
            if (!activity.nId) continue;
            const note2 = getNote(state.notes, activity.nId);
            const noteHlt = getHigherLevelTask(state, note2);
            if (noteHlt === hlt) {
              foundIdx = i;
              break;
            }
          }
          if (foundIdx !== -1) {
            activitiesViewSetIdx(ctx, s, foundIdx, true);
          }
        }
      }
      const listNavigation = getNavigableListInput(ctx, s.activityListPositon.idx, lo, hi);
      if (listNavigation) {
        activitiesViewSetIdx(ctx, s, listNavigation.newIdx, false);
      }
    } else if (currentActivity && isBreak(currentActivity)) {
      let command;
      let editNext;
      if (s.isEditing === EDITING_TIME) {
        command = "Edit break info";
        editNext = EDITING_ACTIVITY;
      } else {
        command = "Edit time";
        editNext = EDITING_TIME;
      }
      if (hasDiscoverableCommand(ctx, keyboard.tabKey, command, BYPASS_TEXT_AREA | REPEAT)) {
        ctx.handled = true;
        s.isEditing = editNext;
      }
    } else {
      if (hasDiscoverableCommand(ctx, keyboard.tabKey, "Do literally nothign", BYPASS_TEXT_AREA | REPEAT)) ;
    }
  }
  if (s.currentFocus === FOCUS_DATE_SELECTOR) {
    if (lo > 0 && hasDiscoverableCommand(ctx, keyboard.leftKey, "Prev day", REPEAT)) {
      moveToPrevDay(ctx, s);
      const [lo2, hi2] = getActivityRange(s);
      activitiesViewSetIdx(ctx, s, lo2, false);
    }
    if (!isSameDate(s.now, s.currentViewingDate) && hasDiscoverableCommand(ctx, keyboard.rightKey, "Next day", REPEAT)) {
      moveToNextDay(ctx, s);
    }
    if (lo > 0 && hasDiscoverableCommand(ctx, keyboard.upKey, "Prev day - end", REPEAT)) {
      moveToPrevDay(ctx, s);
      s.currentFocus = FOCUS_ACTIVITIES_LIST;
    }
    if (hasActivitiesToView(s) && hasDiscoverableCommand(ctx, keyboard.downKey, "Activities", REPEAT)) {
      activitiesViewSetIdx(ctx, s, lo, true);
      s.currentFocus = FOCUS_ACTIVITIES_LIST;
    }
    if (s.activities.length > 0 && !s.filteredActivities && hasDiscoverableCommand(ctx, keyboard.homeKey, "First day")) {
      setCurrentViewingDate(s, s.activities[0].t);
    }
    if (s.activities.length > 0 && !s.filteredActivities && hasDiscoverableCommand(ctx, keyboard.endKey, "Today")) {
      setCurrentViewingDate(s, s.now);
    }
  }
  if (s.isEditing !== EDITING_NOTHING) {
    if (hasDiscoverableCommand(ctx, keyboard.enterKey, "Finish editing", BYPASS_TEXT_AREA) || hasDiscoverableCommand(ctx, keyboard.escapeKey, "Finish editing", BYPASS_TEXT_AREA)) {
      s.isEditing = EDITING_NOTHING;
      ctx.handled = true;
    }
  }
}
function setCurrentViewingDate(s, newDate) {
  newDate = new Date(newDate);
  floorDateLocalTime(newDate);
  s.currentViewingDate = newDate;
}
function hasActivitiesToView(s) {
  return s._startActivityIdx < s._endActivityIdxEx;
}
function getCurrentFocus(s) {
  const hasActivities = hasActivitiesToView(s);
  if (!hasActivities) {
    return FOCUS_DATE_SELECTOR;
  }
  return s.currentFocus;
}
function imActivitiesList(c, ctx, s) {
  var _a, _b;
  const viewHasFocus = ctx.currentView === s;
  s.now = ctx.now;
  const filter = s.inputs.activityFilter;
  if (imMemo(c, filter)) {
    if (filter) {
      filter.sort((a, b) => a - b);
      s.filteredActivities = [];
      for (let i = 0; i < filter.length; i++) {
        const idx = filter[i];
        const activity = state.activities[idx];
        assert(!!activity);
        s.filteredActivities.push(activity);
      }
      const current = arrayAt(s.activities, s.activityListPositon.idx);
      if (current) {
        const idx = s.filteredActivities.indexOf(current);
        if (idx !== -1) {
          activitiesViewSetIdx(ctx, s, idx, NOT_IN_RANGE);
        }
      }
    } else {
      s.filteredActivities = null;
    }
  }
  if (imMemo(c, s.filteredActivities)) {
    if (s.filteredActivities) {
      s.activities = s.filteredActivities;
    } else {
      s.activities = state.activities;
    }
  }
  const viewHasFocusChanged = imMemo(c, viewHasFocus);
  if (viewHasFocusChanged) {
    if (!viewHasFocus) {
      s.currentFocus = FOCUS_ACTIVITIES_LIST;
    }
  }
  const currentNote = getCurrentNote(state);
  if (imMemo(c, currentNote) && !viewHasFocus) {
    const idx = s.activityListPositon.idx;
    if (boundsCheck(s.activities, idx)) {
      const activity = s.activities[idx];
      if (activity.nId !== state.currentNoteId) {
        let newActivityIdx = -1;
        for (let i = state.activities.length - 1; i >= 0; i--) {
          const activity2 = state.activities[i];
          if (activity2.nId === state.currentNoteId) {
            newActivityIdx = i;
            break;
          }
        }
        if (newActivityIdx !== -1) {
          activitiesViewSetIdx(ctx, s, newActivityIdx, NOT_IN_RANGE);
        }
      }
    }
  }
  if (imMemo(c, s.currentViewingDate)) {
    s._startActivityIdx = getActivitiesForDateStartIdx(s.activities, s.currentViewingDate, s._startActivityIdx);
  }
  s._endActivityIdxEx = getActivitiesNextDateStartIdx(s.activities, s._startActivityIdx);
  const hasActivities = hasActivitiesToView(s);
  const currentFocus = getCurrentFocus(s);
  s._canMoveToPrevDay = s._startActivityIdx !== 0;
  s._canMoveToNextDay = s._endActivityIdxEx !== s.activities.length;
  if (viewHasFocus) {
    handleKeyboardInput(ctx, s);
  }
  imLayout(c, COL);
  imFlex(c);
  {
    imLayout(c, ROW);
    imListRowCellStyle(c);
    imAlign(c);
    imJustify(c);
    {
      if (isFirstishRender(c)) {
        elSetStyle(c, "fontWeight", "bold");
      }
      let text = "[Shift+B] to take a break";
      const last = getLastActivity(state);
      if (last && isBreak(last)) {
        text = "Taking a break...";
        if (last.breakInfo) {
          text = "Taking a break: " + last.breakInfo;
        }
      }
      imStr(c, text);
    }
    imLayoutEnd(c);
    const dateSelectorFocused = currentFocus === FOCUS_DATE_SELECTOR;
    imListRowBegin(
      c,
      dateSelectorFocused,
      viewHasFocus && dateSelectorFocused
    );
    {
      if (isFirstishRender(c)) {
        elSetStyle(c, "fontWeight", "bold");
      }
      imLayout(c, ROW);
      imFlex(c);
      imListRowCellStyle(c);
      imGap(c, 1, CH);
      {
        imLayout(c, BLOCK);
        imFlex(c);
        imLayoutEnd(c);
        if (imIf(c) && dateSelectorFocused && s._canMoveToPrevDay) {
          imLayout(c, BLOCK);
          imStr(c, "<-");
          imLayoutEnd(c);
        }
        imIfEnd(c);
        imLayout(c, ROW);
        {
          let dateText;
          if (isSameDate(s.currentViewingDate, s.now)) {
            dateText = " today (" + formatDate(s.currentViewingDate, true) + ")";
          } else {
            dateText = " on " + formatDate(s.currentViewingDate, true);
          }
          let text;
          if (dateSelectorFocused || !hasActivities) {
            text = dateText;
          } else {
            const numActivities = s._endActivityIdxEx - s._startActivityIdx;
            const relIdx = s.activityListPositon.idx - s._startActivityIdx;
            text = "Activity " + (relIdx + 1) + "/" + numActivities + dateText;
          }
          imStr(c, text);
          if (imIf(c) && filter) {
            imStr(c, `[Filtered, ${filter.length} entries]`);
          }
          imIfEnd(c);
        }
        imLayoutEnd(c);
        if (imIf(c) && dateSelectorFocused && s._canMoveToNextDay) {
          imLayout(c, BLOCK);
          imStr(c, "->");
          imLayoutEnd(c);
        }
        imIfEnd(c);
        imLayout(c, BLOCK);
        imFlex(c);
        imLayoutEnd(c);
      }
      imLayoutEnd(c);
    }
    imListRowEnd(c);
    imLine(
      c,
      LINE_HORIZONTAL,
      1,
      !!s.scrollContainer.root && s.scrollContainer.root.scrollTop > 1
    );
    const list = imNavListBegin(
      c,
      s.scrollContainer,
      s.activityListPositon.idx,
      viewHasFocus && currentFocus === FOCUS_ACTIVITIES_LIST,
      !!s.isEditing
    );
    {
      const current = getCurrentNote(state);
      const hlt = getHigherLevelTask(state, current);
      while (navListNextItemSlice(
        list,
        s._startActivityIdx,
        s._endActivityIdxEx
      )) {
        const { i, itemSelected } = list;
        const activity = s.activities[i];
        imKeyedBegin(c, activity);
        {
          const isEditingActivity = viewHasFocus && itemSelected && s.isEditing === EDITING_ACTIVITY;
          const isEditingTime = viewHasFocus && itemSelected && s.isEditing === EDITING_TIME;
          let itemHighlighted = itemSelected;
          if (!itemHighlighted && hlt) {
            if (activity.nId) {
              const note = getNote(state.notes, activity.nId);
              const noteHlt = getHigherLevelTask(state, note);
              if (noteHlt === hlt) {
                itemHighlighted = true;
              }
            }
          }
          const isBreakActivity = isBreak(activity);
          imNavListRowBegin(c, list, itemHighlighted);
          {
            imLayout(c, ROW);
            imListRowCellStyle(c);
            imGap(c, 10, PX);
            imFlex(c);
            imAlign(c);
            {
              imLayout(c, INLINE_BLOCK);
              {
                if (imIf(c) && isEditingTime) {
                  const lowerBound = (_a = get(s.activities, i - 1)) == null ? void 0 : _a.t;
                  const upperBound = (_b = get(s.activities, i + 1)) == null ? void 0 : _b.t;
                  const { edit, textArea } = imEditableTime(c, activity.t, lowerBound ?? null, upperBound);
                  if (edit) {
                    let newVal;
                    if (edit.timeInput) {
                      newVal = edit.timeInput;
                    } else if (edit.durationInput) {
                      newVal = cloneDate(upperBound ?? null) || /* @__PURE__ */ new Date();
                      newVal.setTime(newVal.getTime() - edit.durationInput);
                    }
                    if (newVal) {
                      newVal = clampDate(newVal, lowerBound ?? null, upperBound ?? null);
                      activity.t = newVal;
                      debouncedSave(ctx, state, "Activities list time input");
                      ctx.handled = true;
                    }
                  }
                  ctx.textAreaToFocus = textArea;
                  ctx.focusWithAllSelected = true;
                } else {
                  imIfElse(c);
                  imLayout(c, BLOCK);
                  imStr(c, formatTime(activity.t));
                  imNoWrap(c);
                  imLayoutEnd(c);
                }
                imIfEnd(c);
                const duration = getActivityDurationMs(activity, s.activities[i + 1]);
                imLayout(c, BLOCK);
                imStr(c, formatDuration(duration, 2));
                imNoWrap(c);
                imLayoutEnd(c);
              }
              imLayoutEnd(c);
              imLine(c, LINE_VERTICAL, 1);
              let text = getActivityText(state, activity);
              imLayout(c, ROW);
              imAlign(c);
              imJustify(c, isBreakActivity ? CENTER : NONE);
              imFlex(c);
              {
                if (imMemo(c, isBreakActivity)) {
                  elSetStyle(c, "padding", isBreakActivity ? "40px" : "0");
                }
                const isEditingActivityChanged = imMemo(c, isEditingActivity);
                if (imIf(c) && !isEditingActivity) {
                  imLayout(c, BLOCK);
                  imStr(c, text);
                  imLayoutEnd(c);
                } else {
                  imIfElse(c);
                  const [, textArea] = imTextAreaBegin(c, {
                    value: activity.breakInfo ?? "",
                    placeholder: "Enter break info"
                  });
                  {
                    const input = imOn(c, EV_INPUT);
                    const change = imOn(c, EV_CHANGE);
                    if (input || change) {
                      activity.breakInfo = textArea.value;
                      debouncedSave(ctx, state, "Break info input");
                      ctx.handled = true;
                    }
                    if (isEditingActivityChanged) {
                      textArea.selectionStart = textArea.value.length;
                      textArea.selectionEnd = textArea.value.length;
                    }
                    ctx.textAreaToFocus = textArea;
                    ctx.focusWithAllSelected = true;
                  }
                  imTextAreaEnd(c);
                }
                imIfEnd(c);
              }
              imLayoutEnd(c);
            }
            imLayoutEnd(c);
          }
          imNavListRowEnd(c);
        }
        imKeyedEnd(c);
      }
      imKeyedBegin(c, "footer");
      {
        if (imIf(c) && !hasActivities) {
          imLayout(c, ROW);
          imFlex(c);
          imAlign(c);
          imJustify(c);
          {
            imStr(c, s.activities.length === 0 ? "No activities yet!" : "No activities today");
          }
          imLayoutEnd(c);
        }
        imIfEnd(c);
      }
      imKeyedEnd(c);
    }
    imNavListEnd(c, list);
  }
  imLayoutEnd(c);
}
function newTimer() {
  return {
    t0: 0,
    ticks: 0,
    enabled: true
  };
}
function timerRepeat(s, t, repeatTime, enabled) {
  if (s.enabled !== enabled) {
    if (!s.enabled) {
      s.t0 = t;
      s.ticks = 0;
    }
    s.enabled = enabled;
  }
  if (!enabled) return false;
  const currentTime = t - s.t0;
  {
    if (currentTime > repeatTime) {
      s.t0 = t;
      s.ticks++;
      return true;
    }
  }
  return false;
}
function imTimerRepeat(c, repeatTime, enabled = true) {
  let s = imGet(c, newTimer);
  if (!s) s = imSet(c, newTimer());
  return timerRepeat(s, performance.now() / 1e3, repeatTime, enabled);
}
function imAsciiIcon(c, icon, sizePx) {
  imLayout(c, BLOCK);
  {
    if (isFirstishRender(c)) {
      elSetStyle(c, "userSelect", "none");
      elSetStyle(c, "whiteSpace", "pre");
      elSetStyle(c, "fontFamily", "Courier");
      elSetStyle(c, "fontWeight", "bold");
      elSetStyle(c, "lineHeight", "1");
      elSetStyle(c, "textShadow", `1px 1px 0px ${cssVarsApp.fgColor}`);
    }
    if (imMemo(c, sizePx)) elSetStyle(c, "fontSize", sizePx + "px");
    imStr(c, icon);
  }
  imLayoutEnd(c);
  return icon;
}
const ASCII_SUN = {
  data: `      ;   :   ;
   .   \\_,!,_/   ,
    \`.,':::::\`.,'
     /:::::::::\\
~ -- ::::::::::: -- ~
     \\:::::::::/
    ,'\`:::::::'\`.
   '   / \`!\` \\   \`
      ;   :   ;     `,
  toString() {
    return this.data;
  }
};
const ASCII_MOON_STARS = {
  data: `
       _..._    *
  *  .::'   \`.    
    :::       :    |  
    :::       :   -+-
    \`::.     .'    |
 *    \`':..-'  .
               * .
      `,
  toString() {
    return this.data;
  }
};
function newFpsCounterState() {
  return {
    renderStart: 0,
    renderEnd: 0,
    frameMs: 0,
    renderMs: 0
  };
}
function fpsMarkRenderingStart(fps) {
  const t = performance.now();
  fps.renderMs = fps.renderEnd - fps.renderStart;
  fps.frameMs = t - fps.renderStart;
  fps.renderStart = t;
}
function fpsMarkRenderingEnd(fps) {
  fps.renderEnd = performance.now();
}
function newWebWorker(args, fn, options) {
  const blobURL = newFunctionUrl(args, fn);
  const worker = new Worker(blobURL);
  URL.revokeObjectURL(blobURL);
  return worker;
}
function newFunctionUrl(args, fn, options) {
  const argsToString = args.map((a) => a.toString()).join(",");
  let src = "(" + fn.toString() + `)(${argsToString})`;
  const fnBlob = new Blob([src], { type: "application/javascript" });
  return URL.createObjectURL(fnBlob);
}
console.log("Note tree v" + VERSION_NUMBER);
const CHECK_INTERVAL_MS = 3e4 * 10;
function getIcon(theme) {
  if (theme === "Light") return ASCII_SUN;
  if (theme === "Dark") return ASCII_MOON_STARS;
  return ASCII_MOON_STARS;
}
function imMainInner(c) {
  let fpsCounter = imGet(c, newFpsCounterState);
  if (!fpsCounter) fpsCounter = imSet(c, newFpsCounterState());
  fpsMarkRenderingStart(fpsCounter);
  let ctx = imGet(c, newGlobalContext);
  if (!ctx) ctx = imSet(c, newGlobalContext());
  imGlobalEventSystemBegin(c, ctx.ev);
  if (!ctx.leftTab) ctx.leftTab = ctx.views.activities;
  if (!ctx.currentView) ctx.currentView = ctx.views.noteTree;
  if (imMemo(c, state.currentTheme)) setTheme(state.currentTheme);
  if (imMemo(c, state.settings.tabStopSize)) {
    elSetStyle(c, "tabSize", "" + state.settings.tabStopSize);
  }
  ctx.now = /* @__PURE__ */ new Date();
  let errorState;
  errorState = imGet(c, inlineTypeId(imTry));
  if (!errorState) {
    errorState = imSet(c, {
      error: null,
      framesSinceError: 0,
      irrecoverableError: null
    });
  }
  if (!imGet(c, inlineTypeId(imGet))) {
    imSet(c, true);
    const worker = newWebWorker([CHECK_INTERVAL_MS], (checkIntervalMs) => {
      let started = false;
      setInterval(() => {
        postMessage("is-open-check");
        if (!started) {
          started = true;
          console.log("Web worker successfuly started! This page can now auto-insert breaks if you've closed this tab for extended periods of time");
        }
      }, checkIntervalMs);
    });
    worker.onmessage = () => {
      autoInsertBreakIfRequired();
    };
    worker.onerror = (e) => {
      console.error("Webworker error: ", e);
    };
    const autoInsertBreakIfRequired = () => {
      const time = /* @__PURE__ */ new Date();
      const lastCheckTime = parseDateSafe(state.breakAutoInsertLastPolledTime);
      if (!!lastCheckTime && time.getTime() - lastCheckTime.getTime() > CHECK_INTERVAL_MS * 2) {
        const lastActivity = getLastActivity(state);
        const time2 = !lastActivity ? lastCheckTime.getTime() : Math.max(lastCheckTime.getTime(), getActivityTime(lastActivity).getTime());
        pushBreakActivity(state, newBreakActivity("Auto-inserted break", new Date(time2), true));
      }
      state.breakAutoInsertLastPolledTime = getTimestamp(time);
      debouncedSave(ctx, state, "Auto-inserted break");
    };
  }
  const tryState = imTry(c);
  try {
    if (imIf(c) && !errorState.error && !errorState.irrecoverableError) {
      handleImKeysInput(ctx, ctx.ev);
      if (imMemo(c, state._notesMutationCounter) === MEMO_CHANGED) {
        if (state._notesMutationCounter !== 0) {
          debouncedSave(ctx, state, "ImMain memoizer - notes mutation");
        }
      }
      if (imMemo(c, state._activitiesMutationCounter) === MEMO_CHANGED) {
        if (state._activitiesMutationCounter !== 0) {
          debouncedSave(ctx, state, "ImMain memoizer - activities mutation");
        }
      }
      {
        imLayout(c, COL);
        imFixed(c, 0, PX, 0, PX, 0, PX, 0, PX);
        {
          const error = state.criticalSavingError || state._criticalLoadingError;
          if (imIf(c) && error) {
            imLayout(c, BLOCK);
            {
              if (isFirstishRender(c)) {
                elSetStyle(c, "color", "white");
                elSetStyle(c, "backgroundColor", "red");
              }
              imStr(c, error);
            }
            imLayoutEnd(c);
          }
          imIfEnd(c);
          let displayColon;
          displayColon = imGet(c, inlineTypeId(Boolean));
          if (!displayColon) displayColon = imSet(c, { val: false });
          if (imTimerRepeat(c, 1)) {
            displayColon.val = !displayColon.val;
          }
          if (imIf(c) && ctx.notLockedIn) {
            imLayout(c, ROW);
            imAlign(c, CENTER);
            {
              imLayout(c, ROW);
              imButton(c);
              imAlign(c);
              imJustify(c);
              imSize(c, 0, NA, 100, PERCENT);
              {
                imLayout(c, BLOCK);
                imSize(c, 10, PX, 0, NA);
                imLayoutEnd(c);
                const nextTheme = state.currentTheme === "Dark" ? "Light" : "Dark";
                let icon = getIcon(state.currentTheme);
                if (elHasMouseOver(c, ctx.ev)) {
                  icon = getIcon(nextTheme);
                }
                imAsciiIcon(c, icon, 4.5);
                if (elHasMouseDown(c, ctx.ev)) {
                  state.currentTheme = nextTheme;
                  debouncedSave(ctx, state, "Theme change");
                }
                imLayout(c, BLOCK);
                imSize(c, 10, PX, 0, NA);
                imLayoutEnd(c);
              }
              imLayoutEnd(c);
              imLine(c, LINE_VERTICAL);
              imLayout(c, ROW);
              imFlex(c);
              {
                imAppHeadingBegin(c);
                {
                  imStr(c, formatDateTime(/* @__PURE__ */ new Date(), displayColon.val ? ":" : " ", true));
                }
                imAppHeadingEnd(c);
              }
              imLayoutEnd(c);
              const root = imLayout(c, ROW);
              imFlex(c);
              imAlign(c);
              imJustify(c);
              {
                if (isFirstishRender(c)) {
                  elSetStyle(c, "fontSize", "20px");
                  elSetStyle(c, "fontWeight", "bold");
                }
                if (imIf(c) && ctx.status.statusTextTimeLeftSeconds > 0) {
                  ctx.status.statusTextTimeLeftSeconds -= getDeltaTimeSeconds(c);
                  const statusTextChanged = imMemo(c, ctx.status.statusText);
                  let t = imGet(c, Math.sin);
                  if (t === void 0 || statusTextChanged) t = 0;
                  t = imSet(c, t + getDeltaTimeSeconds(c));
                  if (imIf(c) && ctx.status.statusTextType === TASK_IN_PROGRESS) {
                    const opacity = ctx.status.statusTextTimeLeftSeconds / ctx.status.statusTextTimeInitialSeconds;
                    elSetStyle(c, "opacity", "" + opacity, root);
                    imLayout(c, BLOCK);
                    {
                      if (isFirstishRender(c)) {
                        elSetStyle(c, "width", "20px");
                        elSetStyle(c, "height", "20px");
                      }
                      elSetStyle(c, "transform", "rotate(" + 5 * t + "rad)");
                      elSetStyle(c, "backgroundColor", cssVarsApp.fgColor);
                    }
                    imLayoutEnd(c);
                  } else {
                    imIfElse(c);
                    elSetStyle(c, "opacity", "1", root);
                  }
                  imIfEnd(c);
                  imLayout(c, BLOCK);
                  imSize(c, 10, PX, 0, NA);
                  imLayoutEnd(c);
                  imLayout(c, BLOCK);
                  imStr(c, ctx.status.statusText);
                  imLayoutEnd(c);
                  if (imIf(c) && ctx.status.statusTextType === TASK_IN_PROGRESS) {
                    imLayout(c, BLOCK);
                    {
                      imStr(c, ".".repeat(Math.ceil(2 * t % 3)));
                    }
                    imLayoutEnd(c);
                  }
                  imIfEnd(c);
                } else {
                  imIfElse(c);
                  const RINGBUFFER_SIZE = 20;
                  let arr;
                  arr = imGet(c, inlineTypeId(Array));
                  if (!arr) arr = imSet(c, {
                    frameMsRingbuffer: new Array(RINGBUFFER_SIZE).fill(0),
                    idx1: 0,
                    renderMsRingbuffer: new Array(RINGBUFFER_SIZE).fill(0),
                    idx2: 0
                  });
                  arr.frameMsRingbuffer[arr.idx1] = fpsCounter.frameMs;
                  arr.idx1 = (arr.idx1 + 1) % arr.frameMsRingbuffer.length;
                  arr.renderMsRingbuffer[arr.idx2] = fpsCounter.renderMs;
                  arr.idx2 = (arr.idx2 + 1) % arr.renderMsRingbuffer.length;
                  let renderMs = 0;
                  let frameMs = 0;
                  for (let i = 0; i < arr.renderMsRingbuffer.length; i++) {
                    renderMs += arr.renderMsRingbuffer[i];
                    frameMs += arr.frameMsRingbuffer[i];
                  }
                  renderMs /= arr.frameMsRingbuffer.length;
                  frameMs /= arr.frameMsRingbuffer.length;
                  imLayout(c, BLOCK);
                  imStr(c, Math.round(renderMs) + "ms/" + Math.round(frameMs) + "ms");
                  imLayoutEnd(c);
                }
                imIfEnd(c);
              }
              imLayoutEnd(c);
              imLayout(c, BLOCK);
              imFlex(c, 2);
              imGap(c, 1, CH);
              imJustify(c, RIGHT);
              {
                if (isFirstishRender(c)) {
                  elSetStyle(c, "fontSize", "18px");
                  elSetStyle(c, "fontWeight", "bold");
                  elSetStyle(c, "textAlign", "right");
                }
                const commands = ctx.discoverableCommands;
                {
                  imFor(c);
                  for (let i = 0; i < commands.stabilizedIdx; i++) {
                    const command = commands.stabilized[i];
                    if (!command.key) continue;
                    imCommandDescription(c, command.key.stringRepresentation, command.desc);
                  }
                  imForEnd(c);
                  const anyFulfilled = ctx.keyboard.shiftKey.held && commands.shiftAvailable || ctx.keyboard.ctrlKey.held && commands.ctrlAvailable || ctx.keyboard.altKey.held && commands.altAvailable;
                  if (imIf(c) && !anyFulfilled) {
                    if (imIf(c) && commands.shiftAvailable) {
                      imCommandDescription(c, ctx.keyboard.shiftKey.stringRepresentation, "Hold");
                    }
                    imIfEnd(c);
                    if (imIf(c) && commands.ctrlAvailable) {
                      imCommandDescription(c, ctx.keyboard.ctrlKey.stringRepresentation, "Hold");
                    }
                    imIfEnd(c);
                    if (imIf(c) && commands.altAvailable) {
                      imCommandDescription(c, ctx.keyboard.altKey.stringRepresentation, "Hold");
                    }
                    imIfEnd(c);
                  }
                  imIfEnd(c);
                  commands.shiftAvailable = false;
                  commands.ctrlAvailable = false;
                  commands.altAvailable = false;
                }
                imLayout(c, BLOCK);
                imSize(c, 10, PX, 0, NA);
                imLayoutEnd(c);
              }
              imLayoutEnd(c);
            }
            imLayoutEnd(c);
          }
          imIfEnd(c);
          imLine(c, LINE_HORIZONTAL, 4);
          if (imIf(c) && ctx.currentView === ctx.views.settings) {
            imSettingsView(c, ctx, ctx.views.settings);
          } else {
            imIfElse(c);
            imLayout(c, ROW);
            imFlex(c);
            {
              let focusRef = imGet(c, newFocusRef);
              if (!focusRef) focusRef = imSet(c, newFocusRef());
              focusRef.focused = ctx.currentView;
              const navList = imViewsList(c, focusRef);
              imLayout(c, COL);
              imFlex(c);
              {
                imNoteTreeView(c, ctx, ctx.views.noteTree);
                addView(navList, ctx.views.noteTree, "Notes");
                if (imIf(c) && ctx.viewingDurations) {
                  imLine(c, LINE_HORIZONTAL, 1);
                  imLayout(c, COL);
                  imFlex(c);
                  {
                    if (isFirstishRender(c)) {
                      elSetStyle(c, "maxHeight", "33%");
                    }
                    imDurationsView(c, ctx, ctx.views.durations);
                    addView(navList, ctx.views.durations, "Durations");
                  }
                  imLayoutEnd(c);
                }
                imIfEnd(c);
              }
              imLayoutEnd(c);
              imLine(c, LINE_VERTICAL, 1);
              if (ctx.currentView !== ctx.views.noteTree && ctx.currentView !== ctx.views.durations) {
                ctx.leftTab = ctx.currentView;
                ctx.notLockedIn = true;
              } else {
                ctx.leftTab = ctx.views.activities;
              }
              if (imIf(c) && ctx.notLockedIn) {
                imLayout(c, COL);
                {
                  if (isFirstishRender(c)) {
                    elSetStyle(c, "width", "33%");
                  }
                  imSwitch(c, ctx.leftTab);
                  switch (ctx.leftTab) {
                    case ctx.views.activities:
                      {
                        imActivitiesList(c, ctx, ctx.views.activities);
                        addView(navList, ctx.views.activities, "Activities");
                      }
                      break;
                    case ctx.views.fastTravel:
                      {
                        imNoteTraversal(c, ctx, ctx.views.fastTravel);
                        addView(navList, ctx.views.fastTravel, "Fast travel");
                      }
                      break;
                    case ctx.views.finder:
                      {
                        imFuzzyFinder(c, ctx, ctx.views.finder);
                        addView(navList, ctx.views.finder, "Finder");
                      }
                      break;
                    case ctx.views.urls:
                      {
                        imUrlViewer(c, ctx, ctx.views.urls);
                        addView(navList, ctx.views.urls, "Url opener");
                      }
                      break;
                  }
                  imSwitchEnd(c);
                }
                imLayoutEnd(c);
              }
              imIfEnd(c);
              {
                const prev = arrayAt(navList.views, getWrappedIdx(navList.idx - 1, navList.imLength));
                const next = arrayAt(navList.views, getWrappedIdx(navList.idx + 1, navList.imLength));
                if (prev && next) {
                  const tabInput = getTabInput(ctx, "Go to " + prev.name, "Go to " + next.name);
                  if (tabInput < 0) {
                    setCurrentView(ctx, prev.focusRef);
                  } else if (tabInput > 0) {
                    setCurrentView(ctx, next.focusRef);
                  }
                }
              }
            }
            imLayoutEnd(c);
          }
          imIfEnd(c);
        }
        imLayoutEnd(c);
      }
      {
        {
          if (hasDiscoverableCommand(
            ctx,
            ctx.keyboard.spaceKey,
            ctx.notLockedIn ? "Lock in" : "Stop locking in",
            CTRL | BYPASS_TEXT_AREA
          )) {
            ctx.notLockedIn = !ctx.notLockedIn;
            setCurrentView(ctx, ctx.views.noteTree);
          }
          if (!ctx.notLockedIn && hasDiscoverableCommand(ctx, ctx.keyboard.escapeKey, "Stop locking in")) {
            ctx.notLockedIn = true;
            setCurrentView(ctx, ctx.views.noteTree);
          }
        }
        if (ctx.currentView !== ctx.views.finder && hasDiscoverableCommand(ctx, ctx.keyboard.fKey, "Find", CTRL | BYPASS_TEXT_AREA)) {
          setCurrentView(ctx, ctx.views.finder);
        }
        if (!ctx.viewingDurations && hasDiscoverableCommand(ctx, ctx.keyboard.dKey, "Duration timesheet")) {
          ctx.viewingDurations = true;
          setCurrentView(ctx, ctx.views.durations);
        } else if (ctx.viewingDurations && hasDiscoverableCommand(
          ctx,
          ctx.keyboard.escapeKey,
          "Close timesheet",
          ctx.currentView === ctx.views.finder ? BYPASS_TEXT_AREA : 0
        )) {
          ctx.viewingDurations = false;
          if (ctx.currentView === ctx.views.durations) {
            setCurrentView(ctx, ctx.views.noteTree);
          }
          ctx.views.activities.inputs.activityFilter = null;
        }
        ctx.notLockedIn;
        {
          if (ctx.currentView !== ctx.views.noteTree && ctx.noteBeforeFocus && hasDiscoverableCommand(
            ctx,
            ctx.keyboard.escapeKey,
            "Back to notes",
            ctx.currentView === ctx.views.finder ? BYPASS_TEXT_AREA : 0
          )) {
            setCurrentNote(state, ctx.noteBeforeFocus.id);
            setCurrentView(ctx, ctx.views.noteTree);
          }
        }
        if (ctx.currentView !== ctx.views.settings, hasDiscoverableCommand(ctx, ctx.keyboard.commaKey, "Settings", CTRL)) {
          setCurrentView(ctx, ctx.views.settings);
        }
        if (hasDiscoverableCommand(ctx, ctx.keyboard.bKey, "Take a break", SHIFT)) {
          setCurrentView(ctx, ctx.views.activities);
          activitiesViewTakeBreak(ctx, ctx.views.activities);
          ctx.handled = true;
        }
        if (!ctx.handled) {
          const keyboard = ctx.keyboard;
          if (keyboard.aKey.pressed && keyboard.ctrlKey.held && !isEditingTextSomewhereInDocument()) {
            ctx.handled = true;
          }
          if (keyboard.tabKey.pressed && !isEditingTextSomewhereInDocument()) {
            ctx.handled = true;
          }
        }
        if (ctx.handled) {
          preventImKeysDefault(ctx.ev);
        }
        if (imMemo(c, ctx.textAreaToFocus) && ctx.textAreaToFocus) {
          const textArea = ctx.textAreaToFocus;
          textArea.focus();
          if (ctx.focusWithAllSelected) {
            textArea.selectionStart = 0;
            textArea.selectionEnd = textArea.value.length;
            ctx.focusWithAllSelected = false;
          }
        }
        ctx.textAreaToFocus = null;
        updateDiscoverableCommands(ctx.discoverableCommands);
      }
      {
        let mutationState;
        mutationState = imGet(c, inlineTypeId(getLastSavedTimestampLocalstate));
        if (!mutationState) mutationState = imSet(c, {
          lastSyncTime: getLastSavedTimestampLocalstate()
        });
        const val = getLastSavedTimestampLocalstate();
        if (val !== mutationState.lastSyncTime) {
          if (mutationState.lastSyncTime !== null) {
            loadState(() => {
              console.log("Reloaded the state!");
            });
          }
          mutationState.lastSyncTime = val;
        }
      }
      errorState.framesSinceError++;
    } else {
      imIfElse(c);
      imLayout(c, BLOCK);
      imStr(c, "An error occured in the main render loop. It's irrecoverable, I'm afraid");
      imLayoutEnd(c);
    }
    imIfEnd(c);
  } catch (e) {
    imTryCatch(c, tryState, e);
    console.error("An error occured while rendering: ", e);
    errorState.error = e;
    if (errorState.framesSinceError !== 0) {
      errorState.framesSinceError = 0;
    } else {
      errorState.irrecoverableError = true;
      errorState.error = e;
    }
  }
  imTryEnd(c, tryState);
  imGlobalEventSystemEnd(c, ctx.ev);
  fpsMarkRenderingEnd(fpsCounter);
}
const cGlobal = [];
function imMainEntry(c) {
  imCacheBegin(c, imMainEntry);
  {
    imDomRootBegin(c, document.body);
    {
      imMainInner(c);
    }
    imDomRootEnd(c, document.body);
  }
  imCacheEnd(c);
}
function imCommandDescription(c, key, action) {
  imLayout(c, INLINE_BLOCK);
  imAlign(c, CENTER);
  imPre(c);
  {
    imStr(c, "[");
    imStr(c, key);
    imStr(c, " - ");
    imStr(c, action);
    imStr(c, "]");
  }
  imLayoutEnd(c);
}
loadState(() => {
  console.log("State: ", state);
  imMainEntry(cGlobal);
});
initCssbStyles();</script>
    </head>
    <body>
    </body>
</html>

